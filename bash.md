https://wangdoc.com/bash/intro.html



# 简介

```
echo $SHELL   # /bin/bash
cat /etc/shells # 查看系统安装的所有shell
bash # 进入 bash环境 exit 
bash --version # echo $BASH_VERSION
```

# 基本语法

```
$ echo hello world  # 把参数原样输出
$ echo "多行 
        文本"
$ echo -n a;echo b; # -n 取消文本末尾回车符
$ echo -e "Hello\nWorld" # -e 解释引号(单引号、双引号)里面的特殊字符
$ echo foo \
  bar  

```

> Bash 单个命令一般都是一行，用户按下回车键，就开始执行。有些命令比较长，写成多行会有利于阅读和编辑，这时可以在每一行的结尾加上反斜杠，Bash 就会将下一行跟当前行放在一起解释。
>
> Bash 使用空格（或 Tab 键）区分不同的参数,如果参数之间有多个空格，Bash 会自动忽略多余的空格。
>
> 分号（`;`）是命令的结束符，使得一行可以放置多个命令

**命令组合符号**

```
Command1 && Command2 # 如果Command1命令运行成功，则继续运行Command2命令
```

```
Command1 || Command2 # 如果Command1命令运行失败，则继续运行Command2命令
```



`type`命令用来判断命令的来源，是 内置命令，还是外部程序。

```
type echo
type ls
type -a  # display all ， -t type
```

tldr 命令查询

> `Ctrl + D`：关闭 Shell 会话
>
> `Shift + PageUp`：向上滚动。
>
> `Shift + PageDown`：向下滚动。
>
> `Ctrl + U`：从光标位置删除到行首。
>
> `Ctrl + K`：从光标位置删除到行尾。

# 模式扩展

> Bash 是先进行扩展，再执行命令。因此，扩展的结果是由 Bash 负责的，与所要执行的命令无关。命令本身并不存在参数扩展，收到什么参数就原样执行。
>
> 模式扩展(globbing)早于正则表达式出现，可以看作是原始的正则表达式。它的功能没有正则那么强大灵活，但是优点是简单和方便。
>
> Bash 允许用户关闭扩展 
> set -o noglob
> set +o noglob
>
> `~`会自动扩展成当前用户的主目录
>
> `~+`会扩展成当前所在的目录，等同于`pwd`命令
>
> `?`字符代表文件路径里面的任意单个字符，不包括空字符。比如，`Data???`匹配所有`Data`后面跟着三个字符的文件名。



`?` 字符扩展属于文件名扩展，只有文件确实存在的前提下，才会发生扩展。如果文件不存在，扩展就不会发生。

```
# 当前目录有 a.txt 文件
$ echo ?.txt
a.txt

# 当前目录为空目录
$ echo ?.txt
?.txt
```



`*`字符代表文件路径里面的任意数量的任意字符，包括零个字符。

`*`不会匹配隐藏文件（以`.`开头的文件）

```
# 显示所有隐藏文件
$ echo .*
```

`*`只匹配当前目录，不会匹配子目录

`*`字符扩展属于文件名扩展，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。

Bash 4.0 引入了一个参数`globstar`，当该参数打开时，允许`**`匹配零个或多个子目录。因此，`**/*.txt`可以匹配顶层的文本文件和任意深度子目录的文本文件。

### 方括号扩展

**方括号扩展**的形式是`[...]`，只有文件确实存在的前提下才会扩展。如果文件不存在，就会原样输出。括号之中的任意一个字符。

`[^...]`和`[!...]`。它们表示匹配不在方括号里面的字符

如果需要匹配`[`字符，可以放在方括号内，比如`[[aeiou]`。如果需要匹配连字号`-`，只能放在方括号内部的开头或结尾，比如`[-aeiou]`或`[aeiou-]`

```
# 存在文件 a.txt 和 b.txt
$ ls [ab].txt
a.txt b.txt
```



### [start-end] 扩展

`[start-end]`，表示匹配一个连续的范围。比如，`[a-c]`等同于`[abc]`，`[0-9]`匹配`[0123456789]`。

```
$ ls report[0-9].txt
report1.txt
report2.txt
report3.txt
```

### 大括号扩展

大括号扩展`{...}`表示分别扩展成大括号里面的所有值，各个值之间使用逗号分隔。比如，`{1,2,3}`扩展成`1 2 3`

```
$ echo {1,2,3}
1 2 3
```

大括号扩展不是文件名扩展。它会扩展成所有给定的值，而不管是否有对应的文件存在。
大括号内部的逗号前后不能有空格。否则，大括号扩展会失效。逗号前后有空格，Bash 就会认为这不是大括号扩展，而是三个独立的参数。

```
$ cp a.log{,.bak}

# 等同于
# cp a.log a.log.bak
```

大括号也可以与其他模式联用，并且总是先于其他模式进行扩展。

```
$ echo {cat,d*}
cat dawg dg dig dog doug dug
```

上面例子中，会先进行大括号扩展，然后进行`*`扩展。

大括号扩展有一个简写形式`{start..end}`，表示扩展成一个连续序列。比如，`{a..z}`可以扩展成26个小写英文字母。

```
$ echo {c..a}
c b a

$ echo {01..5} # 如果整数前面有前导0，扩展输出的每一项都有前导0
01 02 03 04 05

$ echo .{mp{3..4},m4{a,b,p,v}}
.mp3 .mp4 .m4a .m4b .m4p .m4v

$ mkdir {2007..2009}-{01..12}
大括号扩展的常见用途为新建一系列目录。
```

```
for i in {1..4} #循环4次
do
  echo $i
done
```

（`start..end..step`），用来指定扩展的步长。

```
$ echo {0..8..2}
0 2 4 6 8
```

多个简写形式连用，会有循环处理的效果。

```
$ echo {a..c}{1..3}
a1 a2 a3 b1 b2 b3 c1 c2 c3
```

变量扩展

```
 echo $SHELL
 echo ${SHELL}
 echo ${!S*}  
SECONDS SHELL SHELLOPTS SHLVL SSH_AGENT_PID SSH_AUTH_SOCK

${!string*}或${!string@}返回所有匹配给定字符串string的变量名。
```



子命令扩展

`$(...)`可以扩展成另一个命令的运行结果，该命令的所有输出都会作为返回值

```
$ echo $(date) # echo `date` ，支持嵌套
```

算术扩展

`$((...))`可以扩展成整数运算的结果

```
echo $((2 + 2))
```



### 字符类 [[:class:]]

`[[:class:]]`表示一个字符类，扩展成某一类特定字符之中的**一个**

`[[:alnum:]]`：匹配任意英文字母与数字

`[[:alpha:]]`：匹配任意英文字母

`[[:blank:]]`：空格和 Tab 键。

`[[:cntrl:]]`：ASCII 码 0-31 的不可打印字符。

`[[:digit:]]`：匹配任意数字 0-9。

`[[:graph:]]`：A-Z、a-z、0-9 和标点符号。

`[[:lower:]]`：匹配任意小写字母 a-z。

`[[:print:]]`：ASCII 码 32-127 的可打印字符。

`[[:punct:]]`：标点符号（除了 A-Z、a-z、0-9 的可打印字符）。

`[[:space:]]`：空格、Tab、LF（10）、VT（11）、FF（12）、CR（13）。

`[[:upper:]]`：匹配任意大写字母 A-Z。

`[[:xdigit:]]`：16进制字符（A-F、a-f、0-9）

```
echo [[:upper:]]* #匹配大写字母开头的文件名称
```

`[![:digit:]]`匹配所有非数字 ，	!否定

字符类也属于文件名扩展，如果没有匹配的文件名，字符类就会原样输出。

### 量词语法

量词语法用来控制模式匹配的次数。

- `?(pattern-list)`：匹配零个或一个模式。
- `*(pattern-list)`：匹配零个或多个模式。
- `+(pattern-list)`：匹配一个或多个模式。
- `@(pattern-list)`：只匹配一个模式。
- `!(pattern-list)`：匹配零个或一个以上的模式，但不匹配单独一个的模式。

```
$ ls abc?(def)
abc abcdef

$ ls abc+(.txt|.php)
abc.php abc.txt
```

>  `shopt`命令可以调整 Bash 的行为。它有好几个参数跟通配符扩展有关。
>
> 打开`globstar`参数以后，`**`匹配零个或多个子目录。
>
> ```
> $ shopt -s globstar
> $ ls **/*.txt
> a.txt  sub1/b.txt  sub1/sub2/c.txt
> ```



# 引号和转义

> Bash 只有一种数据类型，就是字符串。不管用户输入什么数据，Bash 都视为字符串。因此，字符串相关的引号和转义，对 Bash 来说就非常重要。

```
echo $date
echo \$date
echo \\

echo -e "\a"  # 响铃
```

反斜杠除了用于转义，还可以表示一些不可打印的字符。 

- `\a`：响铃
- `\b`：退格
- `\n`：换行
- `\r`：回车
- `\t`：制表符

换行符前面加上反斜杠转义，就使得换行符变成一个普通字符，Bash 会将其当作空格处理，从而可以将一行命令写成多行。

```
$ mv \
/path/to/foo \
/path/to/bar
```

## 单引号

Bash 允许字符串放在单引号或双引号之中，加以引用。

单引号用于保留字符的字面含义，各种特殊字符在单引号里面，都会变为普通字符。

## 双引号

双引号比单引号宽松，大部分特殊字符在双引号里面，都会失去特殊含义，变成普通字符。

```
echo "*"
*
双引号里面不会进行文件名扩展。
```

```
美元符号（$）、反引号（`）和反斜杠（\）。这三个字符在双引号之中，依然有特殊含义，会被 Bash 自动扩展。
echo "$SHELL"
$ echo "I'd say: \"hello!\""
I'd say: "hello!"

$ echo "hello  # 多行
world"

$ ls "two words.txt" # 文件名称包含空格

echo $(cal)   # 不放在双引号之中，echo就会将所有结果以单行输出，丢弃了所有原始的格式。
echo "$(cal)" # 保存原始命令的输出格式
```

换行符在双引号之中，会失去特殊含义，Bash 不再将其解释为命令的结束，只是作为普通的换行符。所以可以利用双引号，在命令行输入多行文本。
双引号会原样保存多余的空格。

## Here 文档

here document）是一种输入多行字符串的方法

```
<< token # 换行符
text
token  # 顶格
```

```
$ foo='hello world'
$ cat << _EOF_
$foo
"$foo"
'$foo'
_EOF_
```

Here 文档内部会发生变量替换，同时支持反斜杠转义，但是不支持通配符扩展，双引号和单引号也失去语法作用，变成了普通字符。

如果不希望发生变量替换，可以把 Here 文档的开始标记放在单引号之中。

Here 文档的本质是重定向，它将字符串重定向输出给某个命令。

Here 字符串只适合那些可以接受标准输入作为参数的命令，对于其他命令无效，比如`echo`命令就不能用 Here 文档作为参数。

Here 文档还有一个变体，叫做 Here 字符串（Here string），使用三个小于号（`<<<`）表示。

有些命令直接接受给定的参数，与通过标准输入接受参数，结果是不一样的。所以才有了这个语法，使得将字符串通过标准输入传递给命令更方便，

`md5sum`命令只能接受标准输入作为参数，不能直接将字符串放在命令后面，会被当作文件名，

```
md5sum <<< 'ddd' # 等价于  echo 'ddd' | md5sum
```



# 变量

> 环境变量是 Bash 环境自带的变量，进入 Shell 时已经定义好了，也可以由用户从父 Shell 传入子 Shell
> $env  # Bash 变量名区分大小写，`HOME`和`home`是两个不同的变量。
> $printenv

```
variable=value # 等号两边不能有空格

a=z                     # 变量 a 赋值为字符串 z
b="a string"            # 变量值包含空格，就必须放在引号里面
c="a string and $b"     # 变量值可以引用其他变量的值
d="\t\ta string\n"      # 变量值可以使用转义字符
e=$(ls -l foo.txt)      # 变量值可以是命令的执行结果 ,echo $e
f=$((5 * 7))            # 变量值可以是数学运算的结果

```

> 由于`$`在 Bash 中有特殊含义，把它当作美元符号使用时，需要在`$`前面放上反斜杠，进行转义。

读取变量的时候，变量名也可以使用花括号`{}`包围，比如`$a`也可以写成`${a}`。这种写法可以用于变量名与其他字符连用的情况。

```
$ a=foo
$ echo ${a}_file
foo_file
```

如果变量的值本身也是变量，可以使用`${!varname}`的语法，读取最终的值。

删除变量

```
foo=
foo=''
unset NAME 
```

输出变量export

```
export NAME
export NAME=value
```

特殊变量

```
$ echo $? # $? 是上一个命令的退出码，用来判断上一个命令是否执行成功。0成功，非零失败
$ echo $$ # 当前shell的进程ID
logfile=/tmp/output_log.$$  # 用来命名临时文件
$_ 上一个命令的最后一个参数 # echo $_ 
$! 为最近一个后台执行的异步命令的进程 ID
$0 # bash , shell 名称
$@和$#表示脚本的参数数量
```

变量的默认值

```
${varname:-word}  # 如果变量varname存在且不为空，则返回它的值，否则返回word。
${varname:=word}  # 如果变量varname存在且不为空，则返回它的值，否则将它设为word，并且返回word
${varname:+word}  
# 如果变量名存在且不为空，则返回word，否则返回空值。它的目的是测试变量是否存在，比如${count:+1}表示变量count存在时返回1（表示true），否则返回空值。

${varname:?message} # 如果变量varname存在且不为空，则返回它的值，否则打印出varname: message，并中断脚本的执行。如果省略了message，则输出默认的信息“parameter null or not set.”。它的目的是防止变量未定义
```

脚本中，变量名的部分可以用数字1到9，表示脚本的参数。如果该参数不存在，就退出脚本并报错。

```
filename=${1:?"filename missing."}
```

## declare

`declare`命令可以声明一些特殊类型的变量，为变量设置一些限制

```
declare OPTION VARIABLE=value
```

- `-a`：声明数组变量。
- `-f`：输出所有函数定义。
- `-F`：输出所有函数名。
- `-i`：声明整数变量。
- `-l`：声明变量为小写字母。
- `-p`：查看变量信息。
- `-r`：声明只读变量。
- `-u`：声明变量为大写字母。
- `-x`：该变量输出为环境变量。# 等同于`export`命令，可以输出一个变量为子 Shell 的环境变量。

`declare`命令如果用在函数中，声明的变量只在函数内部有效，等同于`local`命令。

```
$ declare # 输出当前环境的所有变量，函数
  declare -p # 输出所有变量
  declare -f # 输出所有函数
  
  declare -i val1=1 val2=2
  delcare -i result
  result=val1+val2
  echo $result # 3
  # 如果变量result不声明为整数，val1*val2会被当作字面量，不会进行整数运算。
```



`let`命令声明变量时，可以直接执行算术表达式。

```
$ let foo=1+2
$ echo $foo

$ let "foo = 1 + 2"
$ let "v1 = 1" "v2 = v1++"
```



# 字符串操作

获取字符串长度

```
${#varname}
```

子字符串，字符串截取

```
${varname:offset:length} # offset 0 # 省略 :length 则截取到末尾
# 只能通过变量来读取字符串，并且不会改变原始字符串
```

如果`offset`为负值，表示从字符串的末尾开始算起。注意，负数前面必须有一个空格， 以防止与`${variable:-word}`的变量的设置默认值语法混淆。这时还可以指定`length`，`length`可以是正值，也可以是负值（负值不能超过`offset`的长度）。

```
$ foo="This string is long."
$ echo ${foo: -5}
long.
$ echo ${foo: -5:2}
lo
$ echo ${foo: -5:-2}
lon
```

搜索和替换



























# Wiki

```
> filename # empty file 
```



# crontab

```
第1列   第2列    3      4       5      6

第1列表示分钟0～59 每分钟用*或者 */1表示
第2列表示小时1～23（0表示0点）
第3列表示日期1～31
第4列表示月份1～12
第5列标识号星期0～6（0表示星期天）
第6列要运行的命令
```

```
0 23-7/1 * * * /usr/local/etc/rc.d/lighttpd restart
晚上11点到早上7点之间，每隔一小时重启lighttpd
```

```
10 1 * * 6,0 /usr/local/etc/rc.d/lighttpd restart
上面的例子表示每周六、周日的1 : 10重启lighttpd 。
```

```
/n	n代表数字,表示每隔多久执行一次
```

```
/var/log/cron.log 
```