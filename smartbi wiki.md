电子表格支持表间跳转，支持表内联动

系统支持Oracle、Teradata、MySQL等数据库表和字段的注释作为别名 

8.创建表关系视图时，两表之间可以存在多个字段关联
电子表格支持固定排序，还支持设置允许点击列头排序进行动态排序

电子表格回写支持自增处理

.电子表格公式可以与excel自带的公式结合使用

可视化数据集的输出字段可以修改其是否排序

电子表格支持制作子弹图、手风琴图 

    可视化数据集可在工具栏查看后台执行的SQL 

电子表格报表能直接基于数据源创建

电子表格支持多sheet页报表，以下说法正确的是
可以统一修改所有sheet页标签的背景颜色
 能跨sheet页进行计算公式的取数
 能隐藏sheet页标签， 

 照相机可以设置允许局部刷新
 照相机显示区域能够调整，支持 ctrl+c v, 可以跨sheet页使用

 电子表格单元格属性--过滤中的设置类型：值 数据列 参数

 电子表格报表中，如果想定义某一列的值超过预警值时，使其对应的单元格高亮显示的话，可以使用什么功能实现？
 条件格式

 电子表格打开报表刷新设置：自动刷新    手动刷新 只刷新表样
 电子表格切换参数刷新设置包含：自动刷新    手动刷新  局部刷新

 电子表格字段支持以下哪种显示方式：二维码 条形码 文件 。。。 
 电子表格的格式支持哪些显示格式的设置：图片 金额 二维码
 电子表格计算公式支持以下哪种计算 ： 占比 同比 环比 排名

电子表格在设置填报属性时，可以设置一个字段的值类型有：数字 但行文本 日期 参数

 电子表格设计器关于回写的设置选项：回写规则 填报属性 填报列表

 电子表格设置报表水印的模式：融入背景图 、 前端渲染

 电子表格单元格属性：过滤 扩展  附属 分页 其他

 电子表格单元格属性中的数据设置：分组 列表 汇总
 电子表格拖拽一个字段到表格上，默认的数据设置：分组

 表关系视图中存在多个快捷操作按钮，以便于我们快速进行表关系设置：
 A. 按别名自动建关系
列名
外建

. 电子表格支持点击列头动态排序
B. 电子表格支持设置维内固定升序
C. 不能在汇总单元格上面设置固定排序


关系数据库的数据库管理不可以添加以下什么资源：触发器

 电子表格可以批量插入字段、检查插件版本

 电子表格在单元格属性中的分页属性： 行前分页 行后 列前 列后

 电子表格可以使用以下什么功能达到资源联动效果：   跳转规则 传值

 电子表格支持 echarts A. Excel图形

 电子表格单元格的扩展方式包含：插入单元格 覆盖单元格

 电子表格在设计工具栏的参数设置操作包含：参数排版  引用参数 默认参数

电子表格可以基于以下哪些资源创建 ：
A. 自助数据集
B. 透视分析
C. 关系数据源
D. 可视化数据集

电子表格单元格属性中的过滤功能：
只对字段单元格生效 
B. 过滤可以实现对某一数据列字段的值进行设置
C. 可以使用过滤功能实现多数据集关联查询的报表


关系数据库中的存在同步表操作，可以帮助异地用户同步变更本地的数据，：
同步表后，数据库表增加字段，对已经生成的资源无影响
可以多表同步

数据源连接包含了关系数据库、跨库联合数据源：本地 多维 NoSQL 高度缓存库

计算字段通常使用什么方式获取结果集是什么：计算表达式 SQL表达式


电子表格echarts图形联动传参 ：跳转规则 传值

电子表格参数排版支持哪些操作：
调整参数在参数面板中的显示位置
B. 将参数在参数面板中隐藏
C. 将参数绑定在单元格上（无法移除参数）


左右分片的报表，由于左右两侧的表格存在共同的表格行，因此为了避免相互的影响，可以通过“数据覆盖”或“数据区域”的方式来实现。

电子表格-维内排名
在电子表格中需通过电子表格公式和Excel公式结合可以实现排名。
在E3单元格中输入公式：=RANK(D3,SSR_GetSubCells(D3,B3))

条件格式
：Excel本身的条件格式、电子表格的客户端宏、和电子表格的服务端宏。
支持四中Excel的告警规则："突出显示单元格规则"、"项目选取规则"、“数据条”和“图标集”。
颜色背景色等方式显示异常数据

基本告警主要是指比较常见的根据单元格值的比较来设置单元格颜色、背景色等格式。
建议优先考虑 Excel 条件格式设置。当 Excel 条件格式不能满足需求的时候，再考虑使用前端宏实现。

    选择前端宏时，是否支持导出、打印是选择使用客户端宏还是服务端宏的重要依据。
    若是想使用图片告警方式，目前只支持使用客户端宏来实现。

  















	 电子表格拖拽字段到表格上后，字段的左父格和上父格都默认为“ 有
	
	 电子表格中为了让标题行在分页之后的每一页都还可以继续显示，C. 设置打印标题
	
	 电子表格不支持直接插入以下哪个地图：GIS地图
	
	 电子表格预览时支持导出的种类有哪些：HTML WORD PDF ,not jpg
	
	 chema相关操作是指数据源Schema更多操作的一些功能操作，:同步～ 修改～名称
	
	 计算公式在电子表格中应用广泛，某用户需要拖拽字段制作一张维内排名报表，
	 计算公式在电子表格中应用广泛，某用户需要拖拽字段制作一张维内排名报表，
	 D. 用公式实现排名后可以与排序功能搭配使用


     电子表格可以结合条件格式功能丰富报表的展示效果，以下说法正确的：
     A. 可以使用条件格式在报表中添加增长趋势图标
     C. 可以使用条件格式在报表添加间隔色效
     B. 可以使用条件格式在报表实现组内排名前40%告警
     D. 可以在同个单元格上使用文本高亮显示及图标集显示





# 插件定制开发

扩展插件中的文件会覆盖 Smartbi war包中相同路径下的同名文件。

> .ext\vision\a.js是会替换smartbi.war\vision\a.js文件



扩展插件可以调用 Smartbi 的内部对象。

和 java web 项目类似（war包），里面可以有图片、js、html、css、java、servlet、filter等，只是结构会遵循  Smartbi 的规范，并且多了一些特殊的配置文件，其中有个不同就是 java web 项目WEB-INF目录下的内容对应 Smartbi  扩展包下的META-INF目录；而 web.xml 文件则对应扩展包中的  extension.xml，所以在扩展包中，servlet和filter是需要配置在extension.xml 文件中（但配置结构不变）。



 **同名.js.patch** 文件会修改产品内置同名 js 脚本功能（非覆盖）。在加载 js 脚本时，会遍历所有扩展包，然后将扩展包中同路径及同名的 .js.patch 文件内容附加到产品内置 js 文件的后面，最后返回的是合并后的 js文件，

ConfigurationPatch.js 
系统初始化时会加载 Configuration.js 配置文件；系统会遍历所有扩展包中的 ConfigurationPatch.js，将其合并到 Configuration.js  中并返回到前端，这里的合并是按 json 合并方式合并，也就是两个文件中的 json 对象按 smartbi 指定的合并规则，最后合并为一个  json 对象返回，前端在对应的插入点会读取这些配置项实现相应的功能。



自定义验证类等服务端扩展点，这都是接口性质。



**项目定制化需求开发的插件：** 启动Smartbi服务器，访问http://server_ip:host/smartbi/config。在config界面上，指定插件的存放路径，比如“C: /SmartbiExtension/“目录，然后保存配置。

**研发内部开发的新功能插件：** 修改 smartbi.war/WEB-INF/extensions/extensions.list 文件，每一行为一个插件路径的声明。



  Smartbi 服务器启动时，会自动加载所有插件，并调用相关的激活方法。若插件中存在与smartbi.war中同名的文件时，会优先读取插件中的文件，当多个插件中存在同名文件时会以第一个插件优先，

具。然后从这里下载 [SmartbiPluginApp.zip](https://wiki.smartbi.com.cn/download/attachments/52626670/SmartbiPluginApp.zip?version=1&modificationDate=1597736567000&api=v2) 项目，将其解压到自己的代码开发工作目录下。启动 Eclipse 工具，然后在“**Package Explorer**”窗格上点击右键“**Import...**”，导入刚刚解压的 SmartbiPluginApp 项



 **修改配置**

1、修改SmartbiPluginApp/apache-tomcat-7.0.42/webapps/smartbi/WEB-INF下的web.xml文件，在文件中加入 DevEnv 对应的四行代码。在文件中找到 ProductName 这个  <context-param>，在其下面添加 DevEnv 对应的四行<context-param>，其值为 true。

```
 <context-param>
            <param-name>ProductName</param-name>
            <param-value>Smartbi</param-value>
</context-param>
<context-param>
            <param-name>DevEnv</param-name>
            <param-value>true</param-value>
</context-param> 
```

2、修改同样是web.xml中如图所示的位置

![img](https://cdn.jsdelivr.net/gh/k2easy/picgo/2020/09/2120200921110508.png)



​    3、删除SmartbiPluginApp/apache-tomcat-7.0.42/webapps/smartbi/vision/version.txt 文件
2020-07-31 17:57:19



### 扩展包开发完成后放到SmartbiPluginApp进行调试验证 

​    直接在 SmartbiPluginApp  项目中添加自己的功能，如果是后台代码添加到 /SmartbiPluginApp/src/java  目录下；如果是前端代码、图片、文件全部添加到 /SmartbiPluginApp/src/web/vision 路径下。





# 插件开发

web目录，是插件的根目录。

META-INF目录，是插件的配置文件和相关的类存放位置，类似于Java Web项目的WEB-INF目录的作用。

- classes：包含插件中类文件编译后的class文件（可选）。
- lib目录：插件引用到的类库。Smartbi已经包括的类库，不应该放在此目录中（可选）。
- applicationContext.xml：插件Spring配置文件（可选）。
- extension.xml：插件配置文件（必选）。

vision目录，是前端文件存放位置。

- img目录：资源图片存放目录（可选）。
- js目录：javascript前端文件存放目录（可选）。
- js\ext\ConfigurationPatch.js：前端配置文件，多个插件会自动合并（可选）。

vision目录中，同路径下的同名文件会替换Smartbi相关文件，因此定制开发的文件一般放到ext目录中。

 

   applicationContext.xml文件是插件中的Spring声明文件，该文件是可选的。在java代码中调用服务器端SDK提供的接口时不需要本文件；



| dao         | 接口：smartbi.repository.IDAOModule实现类：smartbi.repository.DAOModule | 处理数据库相关操作。           |
| ----------- | ------------------------------------------------------------ | ------------------------------ |
| state       | 接口：smartbi.state.IStateModule实现类：smartbi.state.StateModule | 处理会话操作。                 |
| catalogtree | 接口：smartbi.catalogtree.ICatalogTreeModule实现类：smartbi.catalogtree.CatalogTreeModule | 处理资源树操作。               |
| usermanager | 接口：smartbi.usermanager.IUserManagerModule实现类：smartbi.usermanager.UserManagerModule | 处理用户管理操作。             |
| rmi         | 实现类：smartbi.framework.rmi.RMIModule                      | 声明前端请求对应的模块。       |
| framework   | 接口：smartbi.framework.IFramework实现类：smartbi.framework.Framework | 处理模块的升级和激活POJO对象。 |

```
<entry><key><value>SystemConfigService</value></key><ref bean="SystemConfigService" /></entry>

<bean id="SystemConfigService" class="smartbi.config.SystemConfigService" factory-method="getInstance"/>

util.removetInvoke("ConfigClientService","getSystemConfig",["itemA"])

java API 
SystemConfigService getSystemConfig

前端调用使用的是 ConfigClientService ，
idea 搜索 SystemConfigService，找到该class ，package smartbi.sdk.service.systemconfig;  发现内部调用使用的是ConfigClientService，同理即可

 
```

  扩展点配置文件ConfigurationPatch.js（可选），对产品Configuration.js文件的扩展，通过配置相应扩展点达到实现某个功能的目的，譬如新增系统选项。

**extensionPoints**是客户端扩展点内容的定义



```
 ``var` `ConfigurationPatch = {
  ``extensionPoints : {
    ``SystemConfig : {
      ``configItem : [ {
        ``tabName: ``"公共设置"``,
        ``groupName : ``"公共设置"``,
        ``itemNumber : 1303,
        ``className : ``"bof.ext.sample6.configitems.ItemA"
      ``} ]
    ``}
  ``}
}
```

  tabName：要增加系统选项设置的tab页名称

​        groupName：每个tab页中分为多个组，此项设置要增加系统选项设置的组名

​       itemNumber：要增加的系统选项设置的id标识

​        className：自定义系统选项实现类的js文件路径







# 调试

?debug=true

**Ctrl + Shift + F2** --》 用于显示/隐藏LOG界面

**Ctrl + Shift + F4** --》用于显示当前对话框对应的js类名。系统中每个对话框，都会对应一个js组件， 仅适用于对话框中。

**鼠标“中键”** --》用于查看资源树对应的类名信息，以便快速定位资源树对应的代码。

​    系统中大量使用资源树的地方，譬如定制管理左侧，新建报表会有让选择数据源等，这些树组件因为逻辑不同会对应不同的js组件，该快捷方式就是快速定位到对应组件。

​    操作步骤为在“资源树”的“展开/收起”图标位置处点击鼠标“中键”。





   单例模式（Singleton Pattern
一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。例如：一个班级只有一个班主任。

```

public class SingleObject {
 
   //创建 SingleObject 的一个对象
   private static SingleObject instance = new SingleObject();
 
   //让构造函数为 private，这样该类就不会被实例化
   private SingleObject(){}
 
   //获取唯一可用的对象
   public static SingleObject getInstance(){
      return instance;
   }
 
   public void showMessage(){
      System.out.println("Hello World!");
   }
}

```





实战：

1、增加验证码

bof.baseajax.common.actions.LoginAction

freequery.lang.compatutil,bof.baseajax.common.LoginView,

freequery.config.configitem.LoginTitleSetting



客户端的 [JS](http://baike.baidu.com/view/16168.htm) 代码，可以在其中添加 debugger 断点，通过浏览器工具可以单步调试。

![img](https://wiki.smartbi.com.cn/download/attachments/52627990/image2019-11-4 15%3A38%3A51.png?version=1&modificationDate=1592978597000&api=v2)

 

Superset 的不足，一方面可以看后续 Airbnb 会不会优化，另一方面可以对其进行二次开发。实际上，Superset 应主要提供基于最终结果表的数据查询和报表展示，对于复杂的数据联动，则放在 ETL 的过程中完成

 

，可以简单把Eclipse中的Project工程理解为IDEA的Module，那么就可以将Smartbi应用以Module的形式导入到IDEA中。



admin demo2020

服务器启动完成之后，就可以正常使用Smartbi的所有功能，但是，此时无法直接在IDEA中查找Smartbi的代码，更不能直接进行调试。因为我们只是将Smartbi应用部署到Tomcat服务器中，并没有加载Smartbi应用到IDEA中。那么接下来，就是将Smartbi应用加载到IDEA，用于查找Smartbi代码并调试。

将smartbiv9.war 解压到 smartbi 文件夹，把该文件夹作为module添加到工程

**快捷键**

Ctrl+N按名字搜索类
Ctrl+Shift+N按文件名搜索文件

Ctrl+H查看类的继承关系，例如HashMap的父类是AbstractMap，子类则有一大堆。

Ctrl+Alt+B查看子类方法实现

Ctrl+B可以查看父类或父方法定义，但是不如ctrl+鼠标左键方便。但

Alt+F7查找类或方法在哪被使用

Ctrl+F/Ctrl+Shift+F按照文本的内容查找，trl+F是在本页查找，Ctrl+Shift+F是全局查找。

trl+F是在本页查找，Ctrl+Shift+F是全局查找。

查看弹窗的对应文件的快捷键，ctrl+shift+F4



查看接口的实现类

IDEA 风格 ctrl + alt +B



部署外部的定制开发扩展包了。Smartbi的扩展包作为一个普通的eclipse项目，同样的，我们可以将扩展包作为一个Module导入IDEA，然后按照Smartbi部署扩展包的方法操作即可。
导入扩展包后，设置扩展包依赖的Librariy，用于开发过程中使用Smartbi及Web相关的类。

让Smartbi加载我们导入的扩展包。

打开smartbi中的smartbi\WEB-INF\extensions\extensions.list文件，将扩展包的web路径添加到列表中。如：D:\Custom\ExtensionTest\src\web。  

然后重启服务器，可看到扩展包已经正常加载。
系统监控 /vision/sysmonitor.jsp 扩展包



**扩展包开发完成后，才需要进行打包**，才可以方便部署到其它Smartbi环境。按如下步骤打包扩展包。

右键扩展包的build.xml文件，选择Add As Ant Build File。

![img](https://cdn.jsdelivr.net/gh/k2easy/picgo/2020/09/2320200923140641.png)



左侧扩展包很多，可以进行分组，统一前缀的会自动放到一组内，如：custom.testExt

**针对内置扩展包的定制**

在使用集成开发环境开发定制扩展包时，由于没有内置扩展包的源码，在自定义的扩展包中无法直接引用内置扩展包中的类。

如：在自定义的扩展包中针对透视分析进行定制，当需要引用到透视分析的类时，会因为找不到类，而提示无法导入。

将打包好的扩展包，制作成一个普通的jar包，然后自定义扩展包添加对改jar包的依赖即可。

扩展包本质就是一个压缩包， 对其进行解压，将里面META-INF\classes目录下的内容，全部放到扩展包根目录。

然后重新压缩，修改压缩文件后缀名为.jar。即制作好了一个内置扩展包的jar包。
将上面制作的jar文件，添加到IDEA的Libraries中。

设置自定义扩展包依赖透视分析扩展包：打开扩展包的src\web\META-INF\extension.xml文件，添加属性**depends=****”****Insight****”**（如果是其它扩展包，则填入其它扩展的名称），后续即可自由引用该内置扩展包的所有类了。



**Chrome调试**

<img src="/Users/demo/Library/Application%20Support/typora-user-images/image-20200923144855861.png" alt="image-20200923144855861" style="zoom:50%;" />

![image-20200923145002982](https://cdn.jsdelivr.net/gh/k2easy/picgo/2020/09/2320200923145003.png)



常用调试技巧-添加debugger，选在功能关键步骤处添加debugger，方便进行调试。程序运行时，会停留在debugger处，然后即可手动执行代码。

常用调试技巧-事件断点
   在需要查找事件方法，或者无源码情况下调试功能查找问题时，添加debugger的方式就会比较困难。此时可以采用事件断点的方式。

例：查找灵活分析”刷新”方法
![image-20200923145324468](https://cdn.jsdelivr.net/gh/k2easy/picgo/2020/09/2320200923145324.png)



常用调试技巧-在源码处设置断点
直接单击代码行号，设置断点。当重新执行代码时（此时不可刷新页面，否则断点设置可能丢失），就会停留在设置断点处，其效果与直接加debugger类似。







# [报表宏开发指南](http://wiki.smartbi.com.cn:18081/pages/viewpage.action?pageId=27001831)

宏的开发实际离不开API，目前现阶段还没有完善的API文档，灵活开发需要了解每个宏对象对应的产品源码，新建一个跳转规则，单步调试进去就可看到，这里列出（有兴趣可以了解[Smartbi前端框架介绍及调试定位入门](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27001830)，辅助理解下面这些对象，里面有些宏里面也可用到的调试技巧）：

| 宏对象              | js脚本                                                       | 所在路径（smartbi.war下）                                    |
| ------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| simpleReport        | QueryView.js                                                 | \vision\js\freequery\query                                   |
| simpleReportContext | QueryNavigator.js                                            | \vision\js\freequery\query                                   |
| meterReport         | Dashboard.js                                                 | \vision\js\bof\decisionpanel\dashboard                       |
| olapQuery           | OlapQueryViewDisplay.js 或 OlapQueryView.js                  | \vision\js\bof\olapquery\olapquery                           |
| chart               | 旧版图形：ChartView.js 以及父类 AbstractChartView.js新版echarts图形：EChartsView.js以及父类 AbstractChartView.js | 旧版图形：\vision\js\smartbi\chart,新版echarts图形：\vision\js\smartbi\echarts |
| page                | NewPage.js                                                   | \vision\js\bof\decisionpanel\newportal                       |
|                     |                                                              |                                                              |
| spreadsheetReport   | SpreadsheetReport.js                                         | \vision\js\smartbi\spreadsheetreport                         |
| INSIGHT             | Insight.js                                                   | \vision\js\smartbi\insight                                   |

报表宏是 JavaScript 的代码集合体，我们也称之为**宏模块**。通过[报表资源抛出的事件](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27001843)（如报表加载事件、报表刷新事件、参数改变事件、点击事件等）对宏脚本触发执行。

注意：如果所有同类报表都需要实现某个功能，除了考虑[资源包](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27001840)，也可以考虑使用扩展包实现，譬如所有灵活分析都添加一个“指标解释”就可以考虑使用扩展包。

报表宏是按照事件进行触发（如报表加载事件、报表刷新事件、参数改变事件、点击事件等）；

 在同一载体里面的报表宏可以相互引用。

### 术语及定义

|                                                              |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [宏代码库](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27001841) | 工具宏用来定义一些公共的宏方法，将一些使用频率较高的方法定义为公共的方法，以便更好的重用，消除重复。各个报表资源的宏、宏资源包都可以使用use语法引用这里的方法。 |
| 宏控制台                                                     | 查看服务端宏代码的后台日志输出。                             |
| 宏模块                                                       | 指的是宏脚本，即 JavaScript 代码集合。                       |
| [宏资源包](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27001840) | 资源包是具有相同特征的一类资源的集合。如来自相同数据源的多个报表资源或多个页面资源的集合。主要用于对多张报表或页面共享同一个宏。 |
| [客户端模块](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27001839) | 表示宏的事件由浏览器端触发，模块里面的宏代码由浏览器端进行处理，例如[电子表格工具栏上添加按钮](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27002069)。 |
| [服务端模块](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27001839) | 表示宏的事件由服务端触发，模块里面的宏代码由服务端进行处理，例如[电子表格根据参数值隐藏行列-服务端宏](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27002034)。 |
| [跳转规则](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27001073) | 跳转规则属于一类特殊的报表宏，是指专门实现报表之间关联跳转功能的报表宏，例如：分析流、报表下钻等分析。 |

 **实现红绿灯的JS代码参考如下：**
选择“simpleReport”对象（当前报表对象），事件选择“onRenderTable”（表格刷新事件）。目的是报表的表格刷新完后触发下面编写的宏代码脚本，如图所示

```
function main(simpleReport, simpleReportContext) {
    var headerRows = simpleReport.grid.getHeaderRows();
    var rowCount = simpleReport.grid.getRowCount();
   
    for(var m= headerRows;m< rowCount;m++){
        //获取"数量"字段所在位置
        var n = simpleReport.getFieldIndexByAlias('数量');
        //获取数量值单元格对象
        var c = simpleReport.grid.getCell(m,n);
        //获取数量值
        var value = c.innerText;
        //去掉数值中的千分位符号
        var floatValue = parseFloat(value.replace(",",""));
        c.align ='right';
        //根据数量大小添加不同的图标
        if (!isNaN(floatValue) && floatValue>1000){
            //添加绿灯图标
            c.innerHTML += '<img src="./img/alertdialog/Icon_8.gif" />';
        }else{
            //添加红灯图标
            c.innerHTML += '<img src="./img/alertdialog/Icon_4.gif" />';      
        }
    }
}
```

通过向导方式定制的跳转规则，系统自动在"服务端模块"和"客户端模块"生成相应的模块宏，
建议：熟悉跳转规则向导并理解其生成的宏脚本，有利于在自定义报表宏时利用里面一切可利用的方法，节省编写时间。

客户端(浏览器)宏主要影响浏览器端的展现效果，除了图形（直接加在图形对象上的部分宏功能可以对导出生效），其他报表的客户端宏都不会对导出有效果。

# 服务端模块

 在应用服务器上运行的，底层原理和[自定义计划任务](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27002108)脚本一样的，都是使用了 [Rhino 工具包](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino/Scripting_Java)，语法遵循Javascript 语法规范，能够引用 Java 类并创建 Java 对象来使用，详细的语法说明见[自定义计划任务](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27002108)。

服务端宏因为在服务器上运行，对浏览器端展现和导出报表都是生效的，但并不是所有报表类型都有服务端宏



 资源包是为了实现批量定制宏。基于资源包定制的宏，表示这些宏对该资源包中的所有报表资源或页面资源皆有效。

![img](https://wiki.smartbi.com.cn/download/attachments/27001840/image2015-11-18 19%3A16%3A20.png?version=1&modificationDate=1466059757000&api=v2)

在宏代码中通过"var jmUtils = use("system.utils.JMClientUtils")"声明调用文件的路径。



Smartbi服务器默认会对返回到客户端的JavaScript代码进行压缩，同时对HTTP Request、Response信息进行加密，为了便于调试，需要在debug模式下访问Smartbi，即在URL中添加debug=true参数。



[报表宏开发示例库](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27001846)



### 宏事件-电子表格

| **类型** | **事件**                    |                                                          |
| -------- | --------------------------- | -------------------------------------------------------- |
| Server   | onBeforeOutput              | 在电子表格生成html之前触发                               |
| Client   | onRenderReport              | 在打开电子表格报表初始化完成后触发                       |
| Client   | onRender                    | 在电子表格报表数据刷新后触发                             |
| Client   | onParamValueChanged         | 在电子表格报表参数改变后触发                             |
| Client   | onLinkClick                 | 在电子表格超链接上点击后触发                             |
| Client   | onChartClick                | 在电子表格图形上点击后触发                               |
| Client   | onWriteBackInsertedRow      | 在可回写的电子表格的工具类上点击“插入行”后触发           |
| Client   | onWriteBackCellValueChanged | 在可回写的电子表格中，修改某个单元格值的时候触发         |
| Client   | onWriteBackSavedData        | 在可回写的电子表格的工具类上点击“保存”，服务器返回后触发 |



### 宏事件-页面

| **类型** | **事件**            |                                                              |
| -------- | ------------------- | ------------------------------------------------------------ |
| Client   | onBeforeRenderPage  | 打开页面布局初始化完成，页面上的资源初始化之前触发           |
| Client   | onRenderPage        | 打开页面初始化完成后触发                                     |
| Client   | onDestroyPage       | 页面对象销毁时触发                                           |
| Client   | onParamValueChanged | 页面公共参数改变后触发                                       |
| Client   | onBackwardDashlet   | 页面上的资源通过跳转规则覆盖原有资源后，点击Dashlet头部的回退按钮触发 |
| Client   | onForwardDashlet    | 页面上的资源通过跳转规则覆盖原有资源后，点击Dashlet头部的回退按钮触发 |



### 宏事件-灵活分析/图形

| **对象**     | **类型**            | **事件**                          |                                    |
| ------------ | ------------------- | --------------------------------- | ---------------------------------- |
| simpleReport | Client              | onRender                          | 在打开灵活分析报表初始化完成后触发 |
| Client       | onRenderTable       | 在灵活分析报表数据刷新后触发      |                                    |
| Client       | onParamValueChanged | 在灵活分析报表参数改变后触发      |                                    |
| chart        | Client              | beforeRender                      | 图形/地图初始化前触发              |
| Client       | afterRender         | 图形/地图初始化完，刷新数据前触发 |                                    |
| Client       | pointClick          | 图形/地图上数据点的点击事件触发   |                                    |



宏事件-仪表分析/透视分析

| **对象**    | **类型**            | **事件**                        |                                           |
| ----------- | ------------------- | ------------------------------- | ----------------------------------------- |
| meterReport | Client              | onRender                        | 仪表分析/地图分析初始化完，刷新数据前触发 |
| Client      | onParamValueChanged | 仪表分析/地图分析参数改变后触发 |                                           |
| INSIGHT     | Server              | beforeBuildHTML                 | 在透视分析生成输出的html之前触发          |
| Client      | onRender            | 在打开透视分析初始化完成后触发  |                                           |
| Client      | onRenderTable       | 透视分析刷新数据后触发          |                                           |
| Client      | onParamValueChanged | 透视报表参数改变后触发          |                                           |



灵活开发需要了解每个宏对象对应的产品源码，宏对象对应源码文件如下

| **宏对象**                      | **js****脚本**                                  |
| ------------------------------- | ----------------------------------------------- |
| simpleReport                    | QueryView.js                                    |
| simpleReportContext             | QueryNavigator.js                               |
| simpleReport（组合分析）        | CombinedQV.js（继承QueryView.js）               |
| simpleReportContext（组合分析） | CombinedQVNavigator.js（继承QueryNavigator.js） |
| meterReport                     | Dashboard.js                                    |
| olapQuery                       | OlapQueryViewDisplay.js  或 OlapQueryView.js    |
| chartView                       | EChartsView.js 以及父类  AbstractChartView.js   |
| page                            | NewPage.js                                      |
| spreadsheetReport               | SpreadsheetReport.js                            |
| INSIGHT                         | Insight.js                                      |

**在报表宏里怎么获取报表页面上指定的****DOM****元素？**

1.直接使用js查找DOM元素

如：getElementsByTagName,getElementById,getElementsByClassName。

2、根据DOM元素的bofid属性获取DOM元素：spreadsheetReport.elem+bofid值



宏对象中不仅包含了很多页面元素，同时还有很多**与报表相关的信息**，比如报表名称、参数信息等，还有**公用的方法**，比如刷新、获取参数值等。

![image-20200923155758591](https://cdn.jsdelivr.net/gh/k2easy/picgo/2020/09/2320200923155758.png)

![image-20200923155727191](/Users/demo/Library/Application%20Support/typora-user-images/image-20200923155732430.png)

![image-20200923155842754](https://cdn.jsdelivr.net/gh/k2easy/picgo/2020/09/2320200923155842.png)



电子表格API文档

![image-20200923160706652](https://cdn.jsdelivr.net/gh/k2easy/picgo/2020/09/2320200923160706.png)



### 服务端宏调试

调试步骤：

1.在宏脚本中使用"logger"对象打印日志信息。

2.打开宏控制台观察日志，入口：定制管理-》系统运维-》调试工具集-》宏控制台。

3.执行报表后，在宏控制台观察日志。

![image-20200923161155679](https://cdn.jsdelivr.net/gh/k2easy/picgo/2020/09/2320200923161155.png)

调试工具集〉宏控制台





chrome调试：

```
var aa = 1; // 断点停止时，右键该变量到watch区域 就能看到该变量的属性
```

cut html标签内容，再copy到某地，预览页面显示效果

![image-20200923171134419](https://cdn.jsdelivr.net/gh/k2easy/picgo/2020/09/2320200923171134.png)





  

通俗讲就是您有多张报表都希望使用宏实现同一个功能，如果每张报表写一个同样的宏维护量太大，这时候就可以考虑使用资源包，在资源包中写一个宏，把需要这个功能的报表添加进来。具体编辑界面见下文。



灵活分析新增刷新按钮

```
   var paramPanel =   document.querySelector('div[bofid="_param"] tbody tr  ');
   var td = document.createElement('td');
   var btnR = document.createElement('button');
   var btnP = document.createElement('button');
   btnR.innerText='刷新';
   btnP.innerText='打印';
   btnR.onclick=function(){
       simpleReport.doRefresh()
   }
   btnP.onclick=function(){
       simpleReport.doPrint();
   }
   td.appendChild(btnR);
    td.appendChild(btnP);
   
   paramPanel.appendChild(td)
      
    
```





# 电子表格服务器端宏函数 doc poi excel 

https://apireference.aspose.com/cells/java/com.aspose.cells/Cell





### 当表格中某些列没有数据时，实现删除该列，同时导出的报表也生效

```
function main(spreadsheetReport) {

    //当表格中某些列没有数据时，实现删除该列，同时导出的报表也生效
  
    var sheet = spreadsheetReport.workbook.getWorksheets().get(0); //获取当前sheet，从0开始计数
    var cells = sheet.cells; 
    var rowCount = cells.rows.count;
    var columnCount = cells.getMaxDataColumn();
    logger.info(rowCount);
    logger.info(columnCount);
     
    
    var blankColumns = [];
    for (var c = 0; c <= columnCount; c++) {
        var isColumnBlank = true;

        for (var r = 1; r < rowCount; r++) {
            var cell = cells.getCell(r, c);
            
            var cellValue = cell.value;
            logger.info(cellValue+' ' +cell.getType())
         
            if (cellValue!=null) {
                isColumnBlank = false;
                break;
            }
        }
        blankColumns.push(isColumnBlank);
    } 
    blankColumns.forEach(function(isBlank, i) {  
        logger.info(i +' '+isBlank);
        if (isBlank) {
            cells.hideColumn(i);
            cells.deleteColumn(i); //
        }
    })



}
```





# 图形宏

图形对象有3个事件 

1、beforeRenderer：图形渲染之前执行，主要用于修改图形样式 options，宏代码执行完成后才刷新图形，所以一般要更改图形的xx展现样式首先想到的是这个宏事件

2 afterRenderer：图形渲染之后执行，主要用于对图形做一些后期处理，可以直接操作图形的dom对象，以及调用图形控件的API方法修正dom

 pointClick:：点击图形对象时触发，主要用于图形跳转处理，可以通过跳转规则向导设置。

```
function main(chartView) {
//  1、获取smartbi中原始图形的options信息,是个json对象
//  json对象的内容对应Echarts配置项手册的内容，可参考 http://echarts.baidu.com/option.html#title
//  options信息可以通过鼠标中键（滚轮）点击图形获取，是json字符串，可以直接贴到Echarts的官网看效果
    var chart = chartView.getChartObject();
    var option = chart.getOptions();
     
//  2、获取option信息后，根据自己的业务需要重新组装options，options的帮助可参考 http://echarts.baidu.com/option.html#title
//  比如，获取数据对象并遍历
    var series = option.series;
    for (var i in series) {
        var seriesItem = series[i];
        data = seriesItem.data;
        delete seriesItem.data; //初始option中去掉data数据，拼在独立的options中。
    }
    var dataOptions = [];
//    ................... 其它业务逻辑
//  示例逻辑，设置表格对象的右边距
    option.grid = {
        right: '110' //空出位置显示timeline组件
    };
     
//  如果只是修改options，到这里就可以结束了。
     
//  如果像demo示例，需要把options整个对象的结果改变，则还要注意下面2点：
//  ................... 其它业务逻辑
//  示例逻辑，使用timeline组件的图形，需要重新组织options
    var newOptions = {
        baseOption: option,
        options: dataOptions
    };   
//  3、把新的options设置到图形对象中，
    chart.setOptions(newOptions);
}
```

```
   ``chartData = chartView.getGridData().data, ``//所有表格数据
   
           // 获取时间轴的数据
        var cellValue = row[option.chartex.timelineFieldIndex].value;
        
```

JS Array
`**slice()**` 方法返回一个新的数组对象，这一对象是一个由 `begin` 和 `end` 决定的原数组的**浅拷贝**（包括 `begin`，不包括`end`）。原始数组不会被改变。

```
const animals = ['ant', 'bison', 'camel', 'duck', 'elephant'];

console.log(animals.slice(2));
// expected output: Array ["camel", "duck", "elephant"]
```

鼠标中键”点击图形以展示当前图形的option配置对象，可以取出Smartbi图形的option配置对象，放到ECharts官网的demo示例中运行。



### Smartbi图形宏

当图形需要根据数据，动态展示一些效果的时候，使用扩展属性也难以满足。

图形加载前（beforeRender），图形加载完成后（afterRender），点击元素（pointClick）

```
chartView： 图形的全局对象，作为参数传入。

• 图形的所有数据：var data = chartView.getGridData();（包括图形未使用的字段数据）

• Smartbi封装的ECharts对象：var smartbiECharts = chartView.getChartObject()

• Smartbi构建的option对象：var options = smartbiECharts.getOptions()

• ECharts的原生实例对象：var echartsInstance = smartbiECharts.getChart()（注意：beforeRender事件中，因图形尚未加载，因此没有ECharts原生实例对象）

• 设置图形option：echarsInstance.setOption(options)
```

![img](https://cdn.jsdelivr.net/gh/k2easy/picgo/2020/09/2520200925100248.png)


 ![img](https://cdn.jsdelivr.net/gh/k2easy/picgo/2020/09/2520200925100314.png)

####   [echartsInstance.](https://echarts.apache.org/zh/api.html#echartsInstance) [dispatchAction](https://echarts.apache.org/zh/api.html#echartsInstance.dispatchAction)  

```
触发图表行为，例如图例开关legendToggleSelect, 数据区域缩放dataZoom，显示提示框showTip等等
```

图形元素点击事件pointClick。在图形宏中获取到option对象，然后根据点击扇区的信息，修改图形标题option.title内容。main(chartView,point){console.log(point)}

      var paramsInfo = [{
            "name": '销售区域',
            "value": name,
            "displayValue": name
    
        }];
    
        var url = 'openresource.jsp?resid=I8a53b78b0174c244c244e2a40174c3db04b90206&' + "&paramsInfo=" + lang.toJSONString(paramsInfo)





页面定时刷新，如果切换到浏览器的其他标签页，浏览器的内存就会持续增长，增长到一定程度就会使浏览器崩溃。

```
function main(page, pageContext) {

    setInterval(function() {

        if(!document.hidden) {

             page.refreshData()

        }    

    },

    1000*5)

}
```

```html
      window.addEventListener('beforeunload', function(event) {
        console.log('I am the 2nd one.');
      });
      window.addEventListener('unload', function(event) {
        console.log('I am the 4th and last one…');
      });
```



elemToolbarTr



elemTdSheets:

# 扩展包开发代码规范 				 		    	 		         			

一个Module类原则 			

​					    一个扩展包中，原则上只能有一个Module类。 			

```
UpgradeHelper.isTableExists(conn,tableName) //先检查表是否存在
```

**知识库实体类原则**

在扩展包中操作知识库表时，必须尽量使用hibernate机制。否则可能因为缓存问 				题而无法实时更新库表。同时也是利用hibernate的优势方便、安全地操作数据库



原则上不允许使用覆盖Smartbi文件的方式扩展功能（除img图片资源）。 				     				在扩展包中可通过在相同路径上创建相同名称的文件，达到覆盖目的。



在使用PostUpgrade升级类导入资源时，需要仔细思考名称及路径的命名，避免出现覆盖目标系统资源或无法导入的情况。另外，不允许在升级类中导入知识库。



**灵活配置原则**

代码中不应该存在写死的配置内容。如果扩展包代码中用到第三方的配置信息或者 				约定的一些固定内容、操作方式，均需要采用系统选项的方式支持客户进行灵活配 				置。比如WebService的URL链接，第三方系统的登录信息，提示框内容，系统编码 				格式，某个功能是否启用等等。

 

出现较多重复代码或重复逻辑时，需要考虑提炼工具方法或工具类。

当使用到数据库连接时，尤其注意要关闭连接池，否则极易导致客户系统连接池溢 				出的严重问题。产品提供了smartbi.util.DbUtil工具类，可以简便关闭连接池。

新增加的扩展插件中如果需要往知识库中增加库表，必须添加对应的知识库对象， 这样 备份知识库 				时候才能将新建的表和表信息备份

当使用空库恢复知识库时候，项目启动过程是。

  1、先启动项目，然后加载扩展包。这时候扩展包里面用于建表的升级类会在数据库建立一张空表。

  2、当项目启动完全时候，点击恢复知识库，这时候项目会先删除掉有注册知识库对象的表，再新建这张表，然后将备份的数据恢复。

每做一项新的定制需求，需要在对应的扩展包下的word文档里记录该需求的需求说明、回复给客户的定制说明、以及定制的开发人员，如果没有word文档，开发人员在扩展包下新建即可。这份文档需要迭代更新到git上面，以保证它最新的动态。

![img](https://cdn.jsdelivr.net/gh/k2easy/picgo/2020/09/2520200925163135.jpg)

### 扩展包自定义Servlet有操作知识库表的必须过TransactionFilter

自定义的Servlet一定要过TransactionFilter这个过滤器把事务管理起来，否则会导致知识库的连接池满，从而使得系统卡死、服务挂起、宕机等严重的问题。

# 					Smartbi开发基础知识点

## Smartbi前端基础框架

```
 下图为Smartbi的前端组件，建议重点看一下底层组件的源码：

• JSLoader.js：加载其他组件的核心类。

• Module2.js：所有基础控件都会继承的类，提供加载并解析组件对应HTML模板等功能。

• Module.js：Module2.js继承的类，提供通用的事件注册和注销等方法。

• util.js：工具类，封装了前端代码常用的方法。如：前后端交互、日期格式转换、验证操作权限等。

• domutils.js：工具类，提供常用的方法。如：识别浏览器版本、操作DOM元素、发送doGet/doPost请求等。

• lang.js：工具类，提供JS类继承、JSON字符串转换等方法。
```

前端使用util.remoteInvokeEx/remoteInvoke与后端Module实现交互。
![img](https://cdn.jsdelivr.net/gh/k2easy/picgo/2020/09/2520200925171104.png)

 Smartbi内置了大量的Module类，通过Module类提供的方法，可以操作Smartbi的各个功能模块。

内置Module类均在applicationContext.xml文件中声明，包括：smartbi应用下的WEB-INF\applicationContext.xml；以及扩展包下的META-INF\applicationContext.xml。



![img](https://cdn.jsdelivr.net/gh/k2easy/picgo/2020/09/2520200925171318.png)

### 动态按需加载JS组件类

Smartbi内置了jsloader全局对象（定义在JS文件中，在入口页面直接通过<script>标签引入），用于按需加载JS类。

```
调用 jsloader.resolve/resolveMany/imports 方法，加载指定的 JS 类。 （注意 ： 只能 加载 vision/js/ 目录下的 JS 类；如一次性加载多个 JS 类，建议使用 resolveMany ） 
```

 

加载完JS类后，即可使用new关键字创建对象使用。（注意：使用imports方法导入的JS类，不会自动创建对象）。

![img](https://cdn.jsdelivr.net/gh/k2easy/picgo/2020/09/2520200925171616.png)



自定义的JS组件类，建议都继承Module2.js，这样就可以直接使用Module2.js及Module.js的方法。继承方法：调用lang.extend方法![img](https://cdn.jsdelivr.net/gh/k2easy/picgo/2020/09/2520200925171752.png)



### JS组件类与HTML模板

 HTML文件一般作为组件的布局和展现文件，通过调用继承的Module2.js类的init方法，默认会自动加载同名的.html/.template文件，也可以使用domutils.doGet(“相对于vision的html完整路径”)方式加载指定的.html或.template文件，从而实现HTML展现模板与JS类的业务代码分离。

```
• 采用doGet方式加载HTML模板：
var FrameView = function(container, disabledAutoFixScroll) {
FrameView.superclass.constructor.call(this);
var template = domutils.doGet("js/freequery/common/FrameView.html");
this._parent.innerHTML = template;
}
```

```
采用父类Module2.js类的init方法自动加载同名的HTML模板：

var FrameView = function(container, disabledAutoFixScroll) {
FrameView.superclass.constructor.call(this);
FrameView.superclass.init.call(this, container, __url, true);
}
```

使用doGet方法加载的HTML模板，需要自行解析获取模板里面的DOM元素。使用Module2.js的init方法加载的HTML模板，会被自动解析元素的bofid属性，后续可通过this.elemBofid（规则：this.elem+bofid值，bofid值首字母大写）直接获取DOM元素对象，同时可自动将符合规则的函数注册为DOM元素对应事件的回调函数，如下图所示。

![img](https://cdn.jsdelivr.net/gh/k2easy/picgo/2020/09/2520200925172948.png)



```
 Module.js封装了注册浏览器事件的方法addListener，基本上Smartbi的JS组件类都会直接，或间接继承Module.js类，一般都可以直接使用this.addListener调用。
 
 // that 可选 处理函数中this指代的对象
 // group 可选 用于对 事件绑定 分组，便于按组解除绑定
 Module.prototype.addListener = function(element,type,handler,that,group)
```

![img](https://jira.smartbi.com.cn:18446/resource/fckeditor/editor/filemanager/download?fdId=1708b0dab95898ba8dcb69b49b589499)



# 对话框

创建一个对话框的业务处理JS类，使其继承BaseDialogEx类。
实现init方法和destroy方法，并分别调用父类BaseDialogEx的init和destroy方法，同时可在init方法中加载HTML模板。
通过Smartbi封装的对话框工具类dialogFactory.js打开对话框。

```
var BaseDialogEx = jsloader.resolve('freequery.dialog.BaseDialogEx')

var TestDialog = function(){

}
TestDialog.prototype.init=function(parent,data,fn,obj,win){
   TestDialog.superclass.init.call(this,)
}
TestDialog.prototype.destroy=function(){
  TestDialog.superclass.destroy.call(thi)
}
lang.extend(TestDialog,BaseDialogEx);

TestDialog.prototype.init=function(parent,data,fn,obj,win){
 TestDialog.superClass.init.call(this,parent,data,fn,obj,win)
 var testDialogTemplate = domUtils.doGet('js/test/dialog/TestDialog.html')
 this.dialogBody.innerHTML= testDialogTemplate
}
```



```
call() 方法使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数。

function Product(name, price) {
  this.name = name;
  this.price = price;
}

function Food(name, price) {
  Product.call(this, name, price);
  this.category = 'food';
}

console.log(new Food('cheese', 5).name);
// expected output: "cheese"

call() 允许为不同的对象分配和调用属于一个对象的函数/方法。

call() 提供新的 this 值给当前调用的函数/方法。你可以使用 call 来实现继承
```



在报表宏中打开对话框

```
simpleReport onRender
function main(simpleReport,simpleReportContext){
  var paramTable = simpleReport.paramPanelObj.layoutTable;
  var lastCell = paramTble.rows[0].insertCell(-1)
  
  var diaglogBtn = document.createElement('input')
  diaglogBtn.value='对话框'
  diaglogBtn.type='button'
  lastCell.appendChild(diaglogBtn)
  simpleReport.addListener(diaglogBtn,'click',dialogTest,simpleReport)
}
 
function dialogTest(){
var DialogFactory = imports('freequery.dialog.dialogFactory')
 var data=['HelloWorld']
 var dialogConfig={
   title:'自定义对话框标题',
   size:DialogFactory.getInstance().size.MIDDLE;
   fullName:'test.dialog.TestDialog'
 };
 DialogFactory.getInstance().showDialog(dialogConfig,data,callback,simpleReport)
}

function callback(ret){
if(ret === true){
  this.refreshData();
}
} 
```





```
扩展包开发过程中，如果需要创建知识库表，同样需要使用Hibernate机制，创建对应的POJO实体类，及对应DAO操作类。创建步骤：

（1） 增加一个与数据库表映射的POJO实体类，不懂的可仿照其他实体类创建方法。

（2） 在自定义Module类的激活方法activate()中调用daoModule.addPOJOClass方法注册新增的实体类。

（3） 新增一个继承 smartbi.repository.AbstractDAO<T, PK>的类（其中T为实体类、PK为实体类的主键），例如public class UserDAO extends AbstractDAO<User, String>，这样可以简化加载、更新、删除、查询实体类的操作
 
```



#### 操作数据库

```
• DbUtil.java：操作数据库工具类，常用方法：getRepoConnection（获取知识库连接），closeDBObject（关闭知识库资源）。

• ConnectionPool.java：连接池处理类，常用方法：ConnectionPool.getConnection(String)（根据数据源ID获取数据库连接）。

• UpgradeHelper.java：升级类辅助类，常用方法：UpgradeHelper.getCreateSQL（自动根据数据库类型组合建表SQL），UpgradeHelper.isTableExists（判断表是否已存在）。
```



**场景示例**

（1） 通过“smartbi.state.StateModule.getInstance().getRequest()”可以获取当前HttpServletRequest对象。这个其实挺实用的，比如前端调用Module类的方法时，就可以拿到HttpServletRequest做很多事情，如设置request属性传值等。

（2） 在Smartbi中使用util.remoteInvoke方法调用Module类时，原则上是必须要登录的，但是产品支持Module类中方法名为login的免登录验证，所以如果有特殊情况需要在未登录状态下访问Module类时，可以将方法名称命名为login。例如：**var** ret = util.remoteInvoke("CustomModule", "login", [ ] );

（3） 产品获取UUID的方法：smartbi.util.UUIDGenerator.generate()

（4） 获取Smartbi配置文件路径（一定会有读写权限）：

BIConfigService.getInstance().getConfigPropFileLocation();

（5） 确认对话框：

**var** flags = modalWindow.MB_YESNO | modalWindow.MB_ICONQUESTION;

alert("请输入正确的公司代码", "提示信息", flags, function(ret) {...});

 **Smartbi计划任务虚拟登录：**

importPackage(Packages.smartbi.state);

importPackage(Packages.smartbi.fake);

**var** req = **new** FakeHttpRequest();

StateModule.getInstance().setRequest(req);

StateModule.getInstance().setSession(req.getSession());

req.getSession().setAttribute("state", new State());

StateModule.getInstance().setCurrentUser(UserManagerModule.getInstance().getUserByName("admin"));

（1） 宏里获取当前用户：

**var** userService =  jsloader.imports("bof.usermanager.UserService").getInstance();

**var** currentUser = userService.getCurrentUser(); //当前登录用户的信息(含id、name、alias等)

（2） 宏里执行SQL语句：

**var** util = jsloader.resolve("freequery.common.util");

**var** ret = util.remoteInvoke("DataSourceService", "executeNoCacheable", ["FoodmartCN", 

​      "select * from t_user", 0, 1000]);

**if** (ret.succeeded && ret.result) {

  **var** data = ret.result.data;//结果集数据，返回一个二维数组

  **return** data[0][0].value;

}

#### 电子表格相关

（1） 电子表格服务端宏aspose-API文档：

[https://apireference.aspose.com/java/cells/com.aspose.cells/Workbook ](https://apireference.aspose.com/java/cells/com.aspose.cells/Workbook)

（2） 电子表格服务端宏常用对象及方法：

获取工作簿：**var** workbook = spreadsheetReport.workbook;

获取sheet： **var** sheets = workbook.worksheets;

根据索引获取sheet：**var** sheet = sheets.get(i);

获取单元格： **var** cells = sheet.getCells();

删除空白列： cells.deleteBlankColumns();

删除空白行： cells.deleteBlankRows();

判断列是否隐藏： cells.isColumnHidden(int index);

判断行是否隐藏： cells.isColumnHidden(int index);

获取操作区域：**var** maxDisplayRange = cells.maxDisplayRange;

取消冻结表头：sheet.unFreezePanes();

去除条件格式： sheet.getConditionalFormattings().clear();

（3） 在电子表格服务端宏中引入扩展包的类：

**var** DAOModule = Packages.smartbi.repository.DAOModule;

**var** QGFangLeiModule = DAOModule.getInstance().loadClass("smartbi.ext.CustomModule");

（4） 在客户端宏获取到扩展的所有单元格位置：

先在服务端宏中打印展开后的所有单元格到客户端：

​      **function** main( spreadsheetReport )  { 

​        spreadsheetReport.printExpandedPositions();//打印展开后所有单元格 

​      }

在客户端宏中即可根据单元格名称获取到单元格位置：

**var** Pos = spreadsheetReport.getExpandedPositions("B3");

（5） 在服务端宏中引入Java类：

**var** FileOutputStream = Packages.java.io.FileOutputStream;

（6） 电子表格服务端宏，修改颜色必须使用setStyle（）方法

3.5 电子表格回写相关

（7） 设置回写单元格的值：

spreadsheetReport.spreadsheetReportWriteBack.setWriteBackCellData(i, 3, result.MATNR, result.MATNR);

（8） 设置回写单元格的焦点：

spreadsheetReport.spreadsheetReportWriteBack.editingCellPosition = "5:3";

（9） 暂时设置回写单元格不可编辑：

回写单元格的位置保存在writableMap中，先将对应位置的属性备份，然后删除对应位置的属性，即可实现不可编辑。

spreadsheetReport.elemSheetFrame.contentWindow.writableMap[a] = spreadsheetReport.elemSheetFrame.contentWindow.writableMap[b]; //先备份

delete spreadsheetReport.elemSheetFrame.contentWindow.writableMap[b]; //再删除

3.6 灵活分析相关

（1） 灵活分析获取指定列的值：

**var** statusIndex = simpleReport.grid.getFieldIndexByName('c_status');

**for** (**var** rowIndex=grid.getHeaderRows(),; rowIndex<grid.getRowCount(); rowIndex++) {

  **var** status = grid.getCell(rowIndex, statusIndex);

}



#### Smartbi定位功能代码常用技巧 				 		    	 		         			

##### 定位对话框JS类（Ctrl + Shift + F4 ）

系统中每个对话框，都会对应一个JS组件，当某个对话框处于打开状态时，可通过快捷键：Ctrl + Shift + F4 显示当前对话框对应的JS类名。取到JS类名之后，即可定位到JS文件。如需调试，在文件中找到对应的入口方法，添加**debugger**即可进行调试。

 定位资源树JS类（鼠标中键）

在“资源树”的“展开/收起”图标位置处点击鼠标“中键”，可以查看该资源树及树节点对应的类名信息，

#### 事件断点

监控浏览器事件，在界面触发事件时进入调试，
source > mouse>click

由于Smartbi封装了浏览器事件，所以一般来说，事件的入口都是相同的，在调试时，需要单步调试进入实际的方法：

![image-20200927111929219](/Users/demo/Library/Application%20Support/typora-user-images/image-20200927111929219.png)

调试过程中，如果出现F10按快了，不小心跳过关键代码，可通过右侧Call Stack来追踪已执行的javascript代码

#### 监控元素属性

当没有对界面操作，界面元素发生变化时，或者希望精准定位元素属性发生变化的代码，可以考虑监控元素属性的变更事件。以进度条为例，在下载时，进度条会随着下载进度而改变，此时通过查看DOM元素，会发现进度条的div元素的with属性在变化： 右键元素 > break on > attribbute modifications 

![img](https://jira.smartbi.com.cn:18446/resource/fckeditor/editor/filemanager/download?fdId=16ed8e88110fcc1b99193a44485808a8)

#### 快捷查找JS类

在Chrome调试工具中，可以直接使用快捷键：Ctrl+P或Ctrl+O查找当前已经加载的文件或JS类。打开后直接添加临时断点，即可进行调试。（注意：只能查找到浏览器加载过的文件）

#### 设置条件断点

在代码中添加临时断点时，可对断点设置触发条件，使其只在满足条件时才进入断点，这样可以在大量重复逻辑中，排除干扰，快速定位到指定情况进行调试。

![image-20200927113820733](https://cdn.jsdelivr.net/gh/k2easy/picgo/2020/09/2720200927113820.png)



#### HTML 元素查找

dom元素是否存在特殊的属性，如bofid、class等属性，然后进行全文搜索，看看能否查找到界面对应的HTML模板文件，如果查找到即可确定对应的JS代码，在JS入口方法处添加**debugger**即可进行调试。

产品在设计上，一般遵循HTML代码与JS代码分离的规则，而HTML对应的JS代码在命名上会保持一致，如**LoginView.html --> LoginView.js**，**ExcelImportView.html --> ExcelImportView.js**。

因此查询元素属性时可先查询***.html, \*.template**（HTML模板文件的两种格式），查询不到，则可能该功能界面没有使用模板，可能是JS代码动态生成的，此时可再考虑用属性值查找***.****js**。

![img](https://cdn.jsdelivr.net/gh/k2easy/picgo/2020/09/2720200927114109.png)

#### 监控请求

Smartbi是按需加载JS组件的，在首次打开某个功能界面时，会加载该功能的所需的JS文件，及其对应的同名html或template模板文件，并且文件命名具有相应功能意义。

#### 监控RMIServlet请求

Smartbi的前后端交互主要通过RMIServlet请求，当功能存在前后端交互时，可通过分析RMIServlet的请求内容，快速定位到前后端代码。

**要观察前后的端数据交互时，需要在URL上添加debug=true参数，否则前后端交互数据会被加密。**



![img](https://jira.smartbi.com.cn:18446/resource/fckeditor/editor/filemanager/download?fdId=16ed8e882787d0d82f76370403abeda9)

注意：当通过类名无法直接查找到Module类时，则代表实际Module类的名称被重新定义过，此时可查找Smartbi.Application\src\web\WEB-INF\applicationContext.xml文件查找类名，找到Module类的实际名称

![img](https://jira.smartbi.com.cn:18446/resource/fckeditor/editor/filemanager/download?fdId=16ed8e88297258c2a54a9904e0eadcc4)

![img](https://cdn.jsdelivr.net/gh/k2easy/picgo/2020/09/2720200927131209.png)







房地产演示demo

http://localhost:18080/smartbi/vision/config.jsp
调整Smartbi日志级别日志为info

由于测算打印的debug日志较多，建议配置调整日志文件大小和日志保留个数，如果测试没问题之后，在建议把smartbi日志至少配置为info或者info以上的级别

# [插件开发](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=51942027)

扩展插件中的文件会覆盖 Smartbi war包中相同路径下的同名文件。.ext\vision\a.js是会替换smartbi.war\vision\a.js文件的，具体示例请见[替换Smartbi文件](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27001777)，至于多个扩展包之间加载顺序请见 [如何设置扩展包加载优先级](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27001801)。

使用场景：
新增独立的功能，譬如新增个jsp、servlet之类，
用户单点登陆（比如客户现场已经有统一登陆平台）之类产品提供了[服务端扩展点](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27001775)功能。
具体示例请见 [插件开发示例库](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27001794)



### [如何设置扩展包加载优先级](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27001801)

修改扩展包中的 extension.xml 文件，在 extension 节点中增加 **priority** 属性，其值就表示该扩展包的加载优先级。该值越小，表示优先级越高。有时候为了保证某个扩展包优先级最高，可以将该值设置为一个极小的值，可以为负值。

注意： 对于完全覆盖的类型(如图片、css、jsp等)，优先级越高，加载顺序越前，以按文件路径找到的第1个插件包(priority值较小)为准。

​      对于*.patch类型，优先级越高，加载顺序越后；如果方法有覆盖的，以最后找到的插件包(priority值较小)的内容为准，这是由于patch是合并机制，js本身是同名方法，后面加载的会覆盖前面的

```
<extension name="LakalaIBA" alias="LakalaIBA" desc="IBA系统-扩展包" priority="-8100" version="1.0">
```

为了设置扩展包之间的相对优先级，还可以使用 **before** 属性，指明当前扩展包应该在某个指定的扩展包之前加载。 

```
<extension name="LakalaIBA" alias="LakalaIBA" desc="IBA系统-扩展包" before="webmoblie" version="1.0">
```

有时多个扩展包之间会有依赖关系，比如扩展包 B 中的 Java 类需要调用扩展包 A 中的方法。如果直接调用的话，通常会遇到 Caused  by: java.lang.NoClassDefFoundError 的错误，提示我们无法找到对应类。错误的原因是，两个扩展包的 Class  Loader 是不一样的。这时我们就需要设置 B 扩展包的 **depends** 属性为 A 扩展包了

系统启动后，可以访问“http://localhost:8080/smartbi/vision/sysmonitor.jsp”页面，查看系统中加载的各个扩展包的优先级是否正确。

## **扩展插件原理**

1. 新增jsp、servlet、filter等实现个性需求

2. 可以覆盖产品同名文件，达到改造产品功能目的

3. 利用同一个 js 文件中多个相同的同名方法，最后一个会生效的原理，smartbi 提供了使用 **同名.js.patch** 方式修改产品内置同名 js 脚本功能。在加载 js 脚本时，会遍历所有扩展包，然后将扩展包中同路径及同名的 .js.patch 文件内容附加到产品内置 js 文件的后面，最后返回的是合并后的 js文件，具体请见 [如何修改Smartbi JS文件](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27001781)，这是最常用的扩展方式，通常如果需要服务端实现部分逻辑的话，就要结合自定义module实现特定功能。

4. 使用系统提供的各种前端插入点修改产品特定功能点，也就是在扩展包中的 ConfigurationPatch.js 文件中配置插入点，达到修改功能的目的。ConfigurationPatch.js 加载原理是：
   1. 客户端请求 smartbi；
   2. 系统初始化时会加载 Configuration.js 配置文件；
   3. 加载 Configuration.js 时，系统会遍历所有扩展包中的 ConfigurationPatch.js，将其合并到  Configuration.js 中并返回到前端，这里的合并是按 json 合并方式合并，也就是两个文件中的 json 对象按 smartbi  指定的合并规则，最后合并为一个 json 对象返回，前端在对应的插入点会读取这些配置项实现相应的功能。

5. 自定义验证类等服务端扩展点，这都是接口性质



| Java查询   | 指基于Java数据源中Java查询对象作为查询源的一种业务查询。     |
| ---------- | ------------------------------------------------------------ |
| 一级模块   | "浏览"、"定制"、"管理"、"个人设置"、"帮助"等功能模块入口。   |
| 二级模块   | 一级模块的子模块入口。                                       |
| 任务面板   | Smartbi 模块主界面中大图标展现的快捷功能操作入口区。         |
| 扩展点     | 为了能够在不改动Smartbi代码的情况下，让新开发的插件无缝集成到系统中，Smartbi系统框架提供了大量的功能插入接口，这些接口即称之为"扩展点"。 |
| 知识库     | 用于存储Smartbi系统资源信息的数据库我们称之为知识库。        |
| 知识库升级 | Smartbi使用升级类代码对知识库版本进行维护，当扩展插件中需要修改知识库对象时就必须添加相应的升级类进行知识库版本的维护。 |
| 知识库对象 | 使用Hibernate运行机制，知识库表映射到一个POJO实体类，该实体类指知识库对象。 |
| 资源树     | 以树的方式展现Smartbi资源。                                  |



**研发内部开发的新功能扩展插件：** 修改 smartbi.war/WEB-INF/extensions/extensions.list 文件，每一行为一个扩展插件路径的声明

**项目定制化需求开发的扩展插件：** 启动Smartbi服务器，访问http://server_ip:host/smartbi/config。在config界面上，指定扩展插件的存放路径，比如“C: /SmartbiExtension/“目录，然后保存配置



Smartbi 服务器启动时，会自动加载所有扩展插件，并调用相关的激活方法。若扩展插件中存在与smartbi.war中同名的文件时，会优先读取扩展插件中的文件，

ConfigurationPatch.js 会自动合并，不存在覆盖问题。



smartbi中很少有页面是使用独立的jsp实现的，基本都是动态拼HTML片段到主界面，定制管理的首页也是如此）





# [Smartbi前端框架介绍及调试定位入门](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27001830)

Smartbi 是典型的基于JavaScript的面向对象框架，整个系统只有几个入口jsp（譬如index.jsp、login.jsp），剩下基于AJAX按业务或操作逻辑按需动态加载或注销组件



![img](https://wiki.smartbi.com.cn/download/attachments/27001830/前端组件.png?version=1&modificationDate=1488447344000&api=v2)

**JS文件**: 使用 jsloader 方式按需加载js文件，jsloader 也是封装了请求gbk.jsp?name=jsname

**CSS文件：**为了减少css的请求，系统采用bof_merge.css.jsp将css合并一次性加载，

**HTML文件**：html文件一般作为组件的布局和展现文件，下面介绍的“2.6  Module2：js组件基类”，如果使用了基类的init方法，默认会自动加载同名的.html文件，也可以使用domutils.doGet("相对于vision的html完整路径")方式加载指定的.html或.template文件

**操作和数据交互**：使用util.remoteInvokeEx/remoteInvoke与[服务端module](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27001789)实现数据交互，如果是希望与jsp/servlet交互，可以使用domutils中提供的doPost/doGet方法交互。很多时候写js组件时，可能都会有与服务端交互的场景，这时候也是需要编写自定义module的，然后在js组件中使用util.remoteInvokeEx/remoteInvoke调用这个module。

## **JSLoader：提供加载js的方法**

一个全局对象jsloader,如果很多地方重复加载一个js，系统会自动缓存，只会从服务器请求一次。jsloader本质是使用gbk.jsp加载要能让jsloader正常加载到js，模块内必须定义一个与文件名同名的全局变量。

```
resolve(name, useGlobal)：按需加载并执行

// 局部加载，等同于局部变量，另外一些不能引用这个变量的地方需要的话又得重新resolve
var util=jsloader.resolve("freequery.common.util");
var CustomEvent = jsloader.resolve("freequery.lang.CustomEvent"); //返回的只是freequery.lang.CustomEvent类，还没有实例化

```

>name：要加载的js名称，是相对于vision/js目录的完整路径名，譬如加载vision/js/freequery/lang/CustomEvent，就是"freequery.lang.CustomEvent"
>useGlobal:是否全局，缺省为false，如果为true，就等同于使用<script>标签加载,，被加载脚本中的全局对象可以直接使用。
>
> 

```
resolveMany(names)：批量加载但不执行 ，意思是批量从服务端请求js，减少与服务端沟通时间  

jsloader.resolveMany(['freequery.common.util','bof.baseajax.common.Application','freequery.widget.Module' ]);
  
// 后面如果再想使用具体的类时：
var util=jsloader.resolve("freequery.common.util"); //这个时候实际不会发起服务端请求的，只是会从缓存里面拿到脚本并eval执行


imports（className）：仅声明待用到再加载与执行
var util = jsloader.imports("freequery.common.util");
// 用的使用需要调用getInstance()去实例化对应的对象，例如：util.getInstance().remoteInvokeEx(...)
```

## **domutils：工具类**

工具类，提供判断浏览器版本、异步请求、给dom元素增加css类等工具类方法，详细可以查看smartbi.war/vision/js/freequery/lang/domutils.js

```
doGet(url,notUseGBKJSP)
//notUseGBKJSP: 是否使用gbk.jsp加载，默认为false，

var template = domutils.doGet("template/freequery/query/QueryView.template");
this.panel = document.createElement("div");
this.panel.innerHTML = template; 
```

```
doPost(url, data, callback, errorHandler, scope, headers)
scope: callback函数内部的this对象
 
    var url = "RMIServlet"; //请求的url
    var data = null; //传递的数据
    data = "className=" + encodeURIComponent(className) +
        "&methodName=" + encodeURIComponent(methodName) +
        "&params=" + encodeURIComponent(paramsStr);
  
    domutils.doPost(url, data, function(responseText) {
        var export2FtpUtil = jsloader.resolve("aladdin.utils.Export2FtpUtil");
        export2FtpUtil.showExportResult(responseText);
    }, function(xhr) {
        alert("导出失败！");
    }, this, null);
  
if (domutils.hasClassName(elem, 'awesomplete')) {
     domutils.addClassName(elem, 'search-wrapper'); //domutils.removeClassName(elem, 'search-wrapper');
}

```

### **util：工具类**

提供了客户端与[服务端module](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27001789)直接沟通的方法，详细的方法可以查看smartbi.war/vision/js/freequery/common/util.js，

remoteInvokeEx /remoteInvoke(className, methodName, paramArray, callback, that, headers) 
与服务端module沟通方法，其中remoteInvokeEx如果同步请求出现异常会自动弹窗提示

```javascript
// 以下示例只是说明用法，实际缺少很多上下文环境，并不能运行
// 同步请求方式
var ret = util.remoteInvoke("DashboardService", "getParamValueFromDashboard", [this.clientId, paramId]);
if (ret.succeeded) {
    return ret.result;
} else {
    modalWindow.showServerError(ret);
}
  
// 异步请求方式
var ret = util.remoteInvoke("DashboardService", "getParamValueFromDashboard", [this.clientId, paramId], function(ret){
    if(ret.succeeded){
        var result = ret.result;  //getParamValueFromDashboard方法返回的结果，如果是服务端返回的是对象，这个就是个json对象
    }
}, this);
```

- getCookie(name)
  获取指定名称cookie值。

- getSystemConfig(key)
  获取指定key的系统选项值。

### **lang：工具类**

提供了类的继承方法、重写等功能。

- extend (subclass, superclass) ：类的继承

```javascript
var BaseDialogEx = jsloader.resolve("freequery.dialog.BaseDialogEx");
  
var ExportResultDialog = function() {
    // 构造函数
};
lang.extend(ExportResultDialog, BaseDialogEx);
  
ExportResultDialog.prototype.init = function(parent, data, fn, obj) {
    ExportResultDialog.superclass.init.call(this, parent, data, fn, obj);
    //BaseDialogEx.superclass.init.call(this, this.dialogBody, __url, true);
    var cookie = document.cookie;
    var cookieAry = cookie.split(';');
    var downloadSrcCookie;
    for (var i in cookieAry) {
        if (cookieAry[i].indexOf('download_src') != -1) {
            downloadSrcCookie = cookieAry[i];
            break;
        }
    }
    var info = "导出成功！";
    this.dialogBody.style.paddingTop = "30px";
    if (downloadSrcCookie) {
        var src = downloadSrcCookie.substring(downloadSrcCookie.indexOf('=') + 1);
        linkStr = '点击<a target="_blank" href="http:/ip:8080/secdoc/encrypt?file=' + src + '">此处</a>下载文件。';
        this.dialogBody.innerHTML = info + linkStr;
    } else {
        this.dialogBody.innerHTML = info;
    }
}
  
ExportResultDialog.prototype.destroy = function() {
    ExportResultDialog.superclass.destroy.call(this);
}
```

## **CustomEvent：自定义事件**

组件希望在某个点抛出事件，供外面调用组件的地方注册使用时

```javascript
var util = jsloader.resolve('freequery.common.util');
var CustomEvent = resolve("freequery.lang.CustomEvent");
  
var SpreadsheetReport = function(container) {
    SpreadsheetReport.superclass.constructor.call(this, container);
    //组件中定义事件方法
    this.onAfterRefresh = new CustomEvent("AfterRefresh", this);
    //触发事件方法：
    //this.onAfterRefresh.fire(this); //其中参数可以任意多个
    //注册事件方法
    //this.onAfterRefresh.subscribe(this.doParamChangeRefresh, this);
    //取消注册事件
    //this.onAfterRefresh.unsubscribe(this.doParamChangeRefresh, this);
}
lang.extend(SpreadsheetReport, "freequery.widget.Module2");
  
SpreadsheetReport.prototype.doParamChangeRefresh = function() {
    this.onAfterRefresh.unsubscribe(this.doParamChangeRefresh, this);
    this.doParamChangeNeedRefresh = false;
    var that = this;
    setTimeout(function() {
        //xx
    }, 1);
}	
```

### **Module2：js组件基类**

freequery.widget.Module2，可以是所有业务逻辑组件的基类，一般情况，编写界面是同名js文件和html文件配套

 1）使用其中的addListener和removeListener方法给dom元素注册事件。

   2）使用其中的init方法，实现了界面逻辑和界面布局的分离，界面布局可以是与组件js文件同目录及同名的.html，这样系统会自动加载布局文件，同时会给布局html文件中定义了bofid的元素自动执行以下操作。

- - 定义了bofid的dom元素，可以在js组件中通过**this.elem+bofid，其中首字母大写**引用，譬如：<span bofid=“testSpan” />，则this.elemTestSpan可以引用该元素
  - js组件可以使用以下方法给元素添加事件：**elem + bofid，其中首字母大写 + 事件名称+_handler**，如果在组件中添加这类规则的方法，系统会自动给对应元素加上对应鼠标事件，譬如elemTestSpan_click_handler，就是给bofid为testSpan的元素添加click事件

   3）destroy方法，注销组件。

```javascript
/**
 * 为一个DOM对象添加事件, 供子类调用
 * 示例：this.addListener(this.elem_btnQuery , "click", this.refreshData , this);
 * @modifier final, protected
 * @param element
 *            一个DOM对象
 * @param type
 *            待绑定的事件类型, 如'click', 'mouseup'. 注意: 不要加'on'前缀
 * @param handler
 *            处理函数
 * @param that
 *            [可选] 处理函数中this所指的对象
 * @param group
 *            [可选] 很少用到. 用于对"事件绑定"分组, 便于按组解除绑定. 见removeListenersByGroup()
 * @return void
 */
Module2.prototype.addListener = function(element, type, handler, that, group) {}
 
/**
 * 解除对一个DOM对象的事件绑定, 供子类调用
 * 示例：this.removeListener(this.elem_btnQuery,"click",this.refreshData);
 * @modifier final, protected
 * @param element
 *            一个DOM对象
 * @param type
 *            待绑定的事件类型, 如'click', 'mouseup'. 注意: 不要加'on'前缀
 * @param handler
 *            处理函数
 * @param that
 *            [可选] 处理函数中this所指的对象
 * @param group
 *            [可选] 绑定时给出的组名. 见addListener()
 * @return void
 */
Module2.prototype.removeListener = function(element, type, handler, that, group) {}
 
/**
 * @param container  父容器dom对象
 * @param url html模板路径或内容，传递__url 代表与当前js组件同目录同名的html文件
 * @param noWrapper  是否创建一个父容器，true or false，缺省是false, 意思是直接用第一个参数container作为第二个参数html内容的父容器，如果为true，会再创建一个父容器包装第二个参数HTML，最后再赋给第一个参数container
 * @param noDoGet 这个是说是否需要请求html内容， true代表不用请求，也就是第二个参数传递的是html内容，false代表需要，就是第二个参数传递的是html模板路径
 */
Module2.prototype.init = function(container, url, noWrapper, noDoGet) {}
```





**布局文件**

布局修改方式通常都是找到对应.html或.template，然后扩展包中同目录下放同名文件即可替换，不过**如果改动比较少，这种方式也尽量少用**，因为涉及到升级风险（升级了新产品，新产品布局或许已发生变化，结果因为扩展包优先，升后还是用扩展包的），所以能**用js代码动态添加dom元素**的也可以考虑。





## 插件开发教程

## [第一课：扩展插件开发基础（内含目录及配置文件介绍）](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27001776)

applicationContext.xml：扩展插件Spring配置文件（可选）。META-INF目录

extension.xml：扩展插件配置文件（必选）。 META-INF目录

- vision目录，是前端文件存放位置。
  - img目录：资源图片存放目录（可选）。
  - js目录：javascript前端文件存放目录（可选）。
  - js\ext\ConfigurationPatch.js：前端配置文件，多个扩展插件会自动合并（可选）。

**说明：**vision目录中，同路径下的同名文件会替换Smartbi相关文件，因此定制开发的文件一般放到ext目录中。



## 插件声明文件extension.xml

| servlet         | 声明扩展插件中的Servlet对象，请参考web.xml中的结构，见下例。 | 可选 |
| --------------- | ------------------------------------------------------------ | ---- |
| servlet-mapping | 声明Servlet的映射，请参考web.xml中的结构，见下例。           | 可选 |
| filter          | 声明扩展插件中的Filter对象，请参考web.xml中的结构，见下例。  | 可选 |
| filter-mapping  | 声明需要过滤的url映射，请参考web.xml中的结构，见下例。       |      |

| name                                                         | 扩展插件的名称。                                             | 必选 |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ---- |
| alias                                                        | 扩展插件的别名。                                             | 必选 |
| desc                                                         | 扩展插件的描述。                                             | 必选 |
| version                                                      | 扩展插件的版本号。                                           | 必选 |
| [priority](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27001801) | 扩展插件的优先级，默认100。值越小，优先级越高。              | 可选 |
| [before](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27001801) | 用于设置扩展包之间的相对优先级，指明当前扩展包应该在某个指定的扩展包之前加载，该属性配置为另一扩展包extension.xml文件的name属性值。 | 可选 |
| [depends](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27001801) | 有时多个扩展包之间会有依赖关系                               |      |



### Spring声明文件applicationContext.xml

仅当需要在扩展插件中使用Smartbi内部模块的方法，或将新增模块组件注册到Framework和RMIModule中时（譬如需要在扩展包实现服务端方法供前端使用），才需要定义此文件

在Smartbi启动过程中会自动加载smartbi.war\WEB-INF\applicationContext.xml初始化内置组件，然后再按扩展插件顺序加载扩展插件中的applicationContext.xml。

在扩展插件中的applicationContext.xml可以直接引用Smartbi内置的对象，只需要通过相应的id引用就可以

| dao         | 接口：smartbi.repository.IDAOModule实现类：smartbi.repository.DAOModule | 处理数据库相关操作。           |
| ----------- | ------------------------------------------------------------ | ------------------------------ |
| state       | 接口：smartbi.state.IStateModule实现类：smartbi.state.StateModule | 处理会话操作。                 |
| catalogtree | 接口：smartbi.catalogtree.ICatalogTreeModule实现类：smartbi.catalogtree.CatalogTreeModule | 处理资源树操作。               |
| usermanager | 接口：smartbi.usermanager.IUserManagerModule实现类：smartbi.usermanager.UserManagerModule | 处理用户管理操作。             |
| rmi         | 实现类：smartbi.framework.rmi.RMIModule                      | 声明前端请求对应的模块。       |
| framework   | 接口：smartbi.framework.IFramework实现类：smartbi.framework.Framework | 处理模块的升级和激活POJO对象。 |



下面示例重新声明内置对象framework和rmi，用于注册新的组件testExt，这种声明方式并不会完全覆盖产品中的framework和rmi，而是会自动合并到内置对象中的List和Map属性

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<beans>
    <bean id="framework" class="bof.framework.Framework" factory-method="getInstance">
        <property name="modules">
            <map>
                <entry>
                    <key>
                        <value>TestExt</value>
                    </key>
                    <ref bean="testExt" />
                </entry>
            </map>
        </property>
    </bean>
    <bean id="rmi" class="bof.framework.rmi.RMIModule" factory-method="getInstance">
        <property name="modules">
            <map>
                <entry>
                    <key>
                        <value>TestExt</value>
                    </key>
                    <ref bean="testExt" />
                </entry>
            </map>
        </property>
    </bean>
    <bean id="testExt" class="bof.extension.test.TestExtensionModule" factory-method="getInstance" >
        <!-- 引用内置组件dao，TestExtensionModule中需要有daoModule的get和set -->
        <property name="daoModule">
            <ref bean="dao" />
        </property>
    </bean>
</beans>
```

### 扩展点配置文件ConfigurationPatch.js（可选）

**ConfigurationPatch.js**包含两个属性，分别是extensionPoints、patches的属性,均为数组，可以定义多个扩展点对象。

extensionPoints:

| MainFrame         | 可以在MainFrame.actions下添加一级菜单模块。      |
| ----------------- | ------------------------------------------------ |
| Custom、Manager等 | 在相应一级模块下添加二级模块、任务面板操作入口。 |
| CatalogTree       | 添加右键菜单。                                   |

Smartbi可供扩展的所有扩展点请参阅"[系统扩展点](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27001775)"。

patches 修改Smartbi原有扩展点内容，或在指定位置插入新的扩展点

| path      | 表示该path要修改的Configuration.js中的对象路径。             |
| --------- | ------------------------------------------------------------ |
| key       | 需要替换的键值，可以为数字或者字符串，当operation为appendObject时忽略此项。0和正数：比如0，代表从左到右第一个键值 负数：比如-1，代表从右到左第一个键值 |
| operation | path的动作，共有以下几种：replace：替换原来的值。 append：添加到原有数组中，value可以为数组或对象。 appendObject：添加到原有对象中，value为是对象。 insert：插入原有数组中。 remove：删除原有对象中的值。 |
| value     | 修改后的值，当operation为remove时忽略此项                    |

```javascript
var ConfigurationPatch = {
    /*调整前端界面：移除一级模块中的定制模块*/
patches: [
        {
            path: "/extensionPoints/Custom/actions",
            key: 6,
            operation: "remove"
        }
    ],
    extensionPoints : {
        /*添加一级模块：在一级模块未尾添加二个模块入口 */
MainFrame : {
            actions : [
                {
                    className :"ext.b.FibonacciAction",
                    groupId :"default" 
                },
                {
                    className :"ext.b.NumberSeriesAction",
                    groupId :"default" 
                }
            ]
        },
        /*添加二级模块：在定制模块的二级模块未尾添加一个模块入口 */
        Custom: {
            actions: [
                {
                    className :"ext.b.FibonacciAction",
                    groupId :"default" 
                }
            ],
             /*添加任务入口：在数据集定义任务面板中添加一个操作入口 */
            DatasetTaskPanel : {
                config: {
                    handlers:[
                        {className:"ext.Custom.CustomTaskPanel"}
                    ]
                }
            }
        },
         /*编辑菜单项：对"定制"->"展现定制"中资源树的右键菜单项进行编辑 */
        CatalogTree: {
    displayCustomHandler:[{className : "ext.b.DisplayCustom_TreePopupMenuHandler"}]
        }
    }
};
```

### 打包扩展插件

接右键扩展包中build.xml文件>Run As > Ant Build打包，默认会打包到扩展包开发目录\dist目录下

系统也支持直接将开发的扩展插件src\web目录直接拷贝到扩展包的加载目录，这样该扩展插件也能被加载。

通过修改smartbi.war/WEB-INF/extensions/extensions.list文件，对扩展插件进行加载。文件中的每一行为一个扩展插件路径的声明 

通过【**定制管理**】-【**系统运维**】-【**调试工具集**】-【**列出已加载扩展插件**】，查看所部署的扩展插件是否已正确加载。 



替换CSS样式文件

```
var ConfigurationPatch = {
    extensionPoints: {
        css : [ 'vision/css/castc.css' ]
    }
};
```

### [新增系统选项](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27001780)

extensionPoints.SystemConfig作为系统选项的扩展点，允许通过该扩展点增加系统选项的设置

```
 var ConfigurationPatch = {
    extensionPoints : {
        SystemConfig : {
            configItem : [ {
                tabName: "公共设置",
                groupName : "公共设置",
                itemNumber : 1303,
                className : "bof.ext.sample6.configitems.ItemA"
            } ]
        }
    }
};
```

```
// 进行初始化化动作并返回一个 tr 元素
xxx.prototype.init = function()
// 检查配置信息是否合法，返回TRUE或者FALSE
xxx.prototype.validate = function()
// 保存配置并返回是否保存成功，对于从系统配置表里的获取数据的配置项来说，返回一个对象
xxx.prototype.save = function()
// 对于从系统配置表里的获取数据的配置项来说，需要在初始化后根据配置信息来显示
xxx.prototype.handleConfig = function(systemConfig)
```

```javascript
var ItemA = function() {
    this.itemName = "新增系统选项A";
    this.dbKey = "NEW_SYSTEM_CONFIG_ITEM_A";
};
lang.extend(ItemA, 'freequery.config.configitem.AbstractSystemConfigItem');
// 进行初始化化动作并返回一个 tr 元素
ItemA.prototype.init = function() {
    this.tr = document.createElement("tr");
    this.tr.height = "30";
    this.td1 = document.createElement("td");
    this.td1.align = "left";
    this.td1.width = "200px";
    this.td1.innerHTML = this.itemName + "：";
    this.tr.appendChild(this.td1);
    this.td2 = document.createElement("td");
    this.td2.innerHTML = "<input type='radio' name='newConfigItemA' id='yes' class='_yes' checked />"
            + "<label >是</label>"
            + "<input type='radio' name='newConfigItemA' id='no'  class='_no' />"
            + "<label >否</label>";
    this.tr.appendChild(this.td2);
    this.td3 = document.createElement("td");
    this.td3.innerHTML = "初始值( 是  )";
    this.tr.appendChild(this.td3);
    this.td4 = document.createElement("td");
    this.td4.innerHTML = "<input class='button-buttonbar-noimage _defBtn ' value='恢复初始值' "
            + "type='button' style='width:100%;' />";
    this.tr.appendChild(this.td4);
    this.radioyes = domutils.findElementByClassName( [ this.tr ], "_yes");
    this.radiono = domutils.findElementByClassName( [ this.tr ], "_no");
    this.resetBtn = domutils.findElementByClassName( [ this.tr ], "_defBtn");
    var that = this;
    this.addListener(this.resetBtn, "click", function() {
        that.radioyes.checked = true;
        that.radiono.checked = false;
    }, this);
    return this.tr;
}
// 检查配置信息是否合法  
ItemA.prototype.validate = function() {
    return true;
}
// 保存配置并返回是否保存成功，对于从系统配置表里的获取数据的配置项来说，返回一个对象
ItemA.prototype.save = function() {
    if (!this.validate())
        return false;
    var obj = {
        key : this.dbKey,
        value : '' + this.radioyes.checked
    };
    return obj;
}
// 对于从系统配置表里的获取数据的配置项来说，需要在初始化后根据配置信息来显示
ItemA.prototype.handleConfig = function(systemConfig) {
    for ( var i in systemConfig) {
        var config = systemConfig[i];
        if (config && config.key == this.dbKey) {
            var v = (config.value == 'true');
            this.radioyes.setAttribute("__checked", v);
            this.radiono.setAttribute("__checked", !v);
            break;
        }
    }
};
```



### [如何修改Smartbi JS文件](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27001781)

   自定义Patch文件进行修改（推荐）        

```
//保存原有方法实现到临时名称中
LoginView.prototype.__elemLogin_click_handler = LoginView.prototype.elemLogin_click_handler;
LoginView.prototype.elemLogin_click_handler = function(ev) {
    alert('Before login');
    // 调用保存的原有方法实现
    this.__elemLogin_click_handler(ev);
    alert('After login');
}
```

### [服务端Java接口调用](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27001782)

 当扩展插件需要调用系统原有方法时，建议使用SDK中的services接口进行调用以统一管理。 服务器端SDK通过Java API提供七项服务接口： 

|                                                          |                                                              |
| -------------------------------------------------------- | ------------------------------------------------------------ |
| smartbi.sdk.service.analysisreport.AnalysisReportService | 多维服务接口。                                               |
| smartbi.sdk.service.catalog.CatalogService               | 资源目录服务接口。                                           |
| smartbi.sdk.service.managereport.ManageReportService     | 指标类报表和复杂报表服务对象,包括取报表对象、汇总报表、校验报表等。 |
| smartbi.sdk.service.operationLog.OperationLogService     | 此类为smartbi操作日志的服务接口,提供对日志操作需要的方法。   |
| smartbi.sdk.service.simplereport.SimpleReportService     | 提供Report对象的工厂方法，实现报表的相关操作。               |
| smartbi.sdk.service.systemconfig.SystemConfigService     | 此类为系统设置的服务接口,获取系统设置选取项。                |
| smartbi.sdk.service.user.UserManagerService              | 此类为用户管理模块的服务接口,提供对用户进行管理时需要的方法，包括新建、修改、删除用户，新建、修改、删除组，新建、修改、删除角色， 给用户设置所属组、给角色添加用户等。 |

```java
获取本地连接
LocalClientConnector conn = new LocalClientConnector();
 
//资源目录树
CatalogService catalogService = new CatalogService(conn);
 String elementId = "I2c9490741d4647ab011d4b92363f2061";
 String elementType = "SIMPLE_REPORT";
boolean result = catalogService.isCatalogElementAccessible(elementId, elementType);
 System.out.println(result);
 
//灵活报表
SimpleReportService simpleReportService = new SimpleReportService(conn);
 String reportId = "I2c9490741d2370a8011d2df3b1fd1fa0";
 Report report = simpleReportService.openReport(reportId);
 System.out.println(report.getCurrentReportName());
 
//指标类报表
ManageReportService reportService = new ManageReportService (conn);
 
//用户管理
UserManagerService userManagerService = new UserManagerService(conn);
 String departmentId = "DEPARTMENT";
 IDepartment department = userManagerService.getDepartmentById(departmentId);
 System.out.println(department.getName());
```



 

  [第六课：高级应用](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=52627082&src=breadcrumbs-parent)             

 Smartbi提供了一个特定的接口smartbi.framework.IModule，实现这个接口，并在插件包的配置文件applicationContext.xml中将module注册到Framework和RMIModule

这样smartbi在系统启动时就会调用自定义module的activate方法执行一些初始化操作，并且这个module中的共有方法都可以在前端异步调用.

可以在module中直接引用公共组件，譬如dao（知识库操作）、state（会话状态）、catalogtree（资源树操作）、usermanager（用户管理），常用组件对应的接口类型见 [开发插件包](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=52626686)里的说明

场景：

1、前后端有异步交互需求时，需要自定义module，在module里实现方法

2、需要编写升级类（或者系统启动成功后执行的升级类）时也需要先写个module；

3、需要在插件包中执行一些系统启动初始化的操作；



  1、util.remoteInvoke/remoteInvokeEx实际是封装了对RMIServlet的请求，其接收三个主要参数：className、methodName、params，这三个参数就是对应remoteInvoke方法的参数

```
var util = jsloader.resolve("freequery.common.util");
/同步请求方式
var ret = util.remoteInvoke("DashboardService", "getParamValueFromDashboard", [this.clientId, paramId]);
if(ret.succeeded) {

//异步请求方式
var ret = util.remoteInvoke("DashboardService", "getParamValueFromDashboard", [this.clientId, paramId], function(ret){
    if(ret.succeeded){
    
    util.remoteInvoke方法需要在登录系统后才可使用
```

2 、RMIServlet接收到className等三个参数为什么会调用对应的module，是因为RMIServlet引用了RMIModule中的modules属性，通过提供的className，找到真实对应的module，这也是为什么编写好的module需要在applicationContext.xml注册到RMIModule的原因之一，



JSP/HTML页面资源一般放在vision目录下

引用的外部jar包放置在META-INF/lib目录

![image-20201009153030997](/Users/demo/Library/Application%20Support/typora-user-images/image-20201009153030997.png)

Smartbi加载扩展包时，会先执行Module类的activate方法，然后依次执行升级类，注意升级类只会执行一次，后续重启服务器不会再执行。

Servlet及Filter的使用与正常的Javaweb基本一致，唯一不同是Servlet和Filter需要配置在extension.xml 文件中。

![image-20201009153402604](/Users/demo/Library/Application%20Support/typora-user-images/image-20201009153404918.png)

![image-20201009153412525](https://cdn.jsdelivr.net/gh/k2easy/picgo/2020/10/0920201009153412.png)







































# [在生产环境调试JS代码的方法](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27001828)

1、先清空浏览器缓存文件。
2、打开登录页面时附带 debug 参数，使服务端对当前客户端的 JS 请求内容不进行压缩。

打开浏览器"JS控制台"，执行下面的示例代码。即可在相应 js 类方法的执行前后都插入debugger断点。

```javascript
( function(jsloader,  breakPoints) {
    var  log = window.console ? window.console.log : function(msg){};
    if  (!jsloader) { log('jsloader not found!'); return; }
    var  clzName, Clazz, Proto, methodNames, len, i;
    for  (clzName in breakPoints) {
       Clazz  = jsloader.resolve(clzName);
       if  (Clazz && (Proto = Clazz.prototype)) {
           methodNames  = breakPoints[clzName];
           for (i  = 0, len = methodNames.length; i < len; i++) {
              (   function(methodName, Proto) {
                  var  tmpName = '__breakpoint_' + methodName;
                  if  (tmpName in Proto) {
                     Proto[methodName]  = Proto[tmpName];
                     Proto[tmpName]  = null;
                     delete  Proto[tmpName];
                     log('Detach  breakpoint: ' + clzName + '.prototype.' +  methodName);
                  }   else if  (Proto[methodName]) {
                     Proto[tmpName]  = Proto[methodName];
                     Proto[methodName]  = function() {
                         debugger;
                         Proto[tmpName].apply(this,  Array.prototype.slice.apply(arguments));
                         debugger;
                     };
                     log('Attach  breakpoint: ' + clzName + '.prototype.' +  methodName);
                  }
              })(methodNames[i],  Proto);
           }
       }
    }
})(window.jsloader, {
    'freequery.query.QueryView' : 'openQueryViewEx,openQueryViewHybrid,refreshData'.split(','),
    'bof.decisionpanel.dashboard.Dashboard' : 'setRefreshChartSize'.split(',')
});
```







this.doCmd("OPEN");



 var url = 'openresource.jsp?resid=I8a53b78b0174c244c244e2a40174c3db04b90206&' + "&paramsInfo=" + lang.toJSONString(paramsInfo)







```
BannerView.prototype.elemCreateAnalysis_click_handler = function(ev) {
    this._currentDropdownElement = this.elemCreateAnalysis;
    this.dropdownElemClickHandler(ev);
}


```









```
	private static final Logger log = Logger.getLogger(UpgradeTask_New.class);

		log.error("新建知识库对象失败，表名：t_ext_visit_index 已存在");
		替代 system.out
		
		
		
```

在扩展包中可以根据Smartbi中英文环境，动态显示中英文。

1.创建多语言文件（固定文件名），采用key=value的方式设置中英文显示内容。（建议安装多语言Propertys编辑工具）

2.在需要动态显示中英文的地方输入多语言key值

Unicode在线转码：http://tool.chinaz.com/tools/unicode.aspx







# JackJson 的使用

jackson-core-2.2.3.jar（核心jar包）
 jackson-annotations-2.2.3.jar（该包提供Json注解支持）
 jackson-databind-2.2.3.jar

```java

User user = new User();
user.setName("小民");
user.setEmail("xiaomin@sina.com");
user.setAge(20);

SimpleDateFormat dateformat = new SimpleDateFormat("yyyy-MM-dd");
user.setBirthday(dateformat.parse("1996-10-01"));


ObjectMapper mapper = new ObjectMapper();
String json = mapper.writeValueAsString(user);

List<User> users = new ArrayList<User>();
users.add(user);
String jsonlist = mapper.writeValueAsString(users);

Json字符串转化成指定Class类
  ObjectMapper mapper = new ObjectMapper();
User user = mapper.readValue(json, User.class);

Json字符串转化成集合List
String jsonString="[{'id':'1'},{'id':'2'}]";
ObjectMapper mapper = new ObjectMapper();
JavaType javaType = mapper.getTypeFactory().constructParametricType(List.class, Bean.class);
//如果是Map类型  mapper.getTypeFactory().constructParametricType(HashMap.class,String.class, Bean.class);  
List<Bean> lst =  (List<Bean>)mapper.readValue(jsonString, javaType);



	
```

\\\

```

var old_click = BannerView.prototype.elemCreateAnalysis_click_handler;


BannerView.prototype.elemCreateAnalysis_click_handler = function(ev) {
    //存在layer全局变量
    layer.open({
       type:2,
        title : '文件上传',
        size : DialogFactory.getInstance().size.MIDDLE,
        content:'js/ext/uploadDialog.html'
    })
};




/*
  this._currentDropdownElement = this.elemCreateAnalysis;

    var dialogConfig = {
        title : '文件上传',
        size : DialogFactory.getInstance().size.MIDDLE,
        fullName : 'ext.UploadDialog'
    };
    DialogFactory.getInstance().showDialog(dialogConfig);  //因为关于窗口关闭时不用执行任何逻辑，所以不用传递第三第四个参数

*/

```



![image-20201012141009312](https://cdn.jsdelivr.net/gh/k2easy/picgo/2020/10/1220201012141009.png)





simpleReport.addListener(exportBtn,'click',simpore.doPrint,simpleReport);





（2） 在Smartbi中使用util.remoteInvoke方法调用Module类时，原则上是必须要登录的，但是产品支持Module类中方法名为login的免登录验证，所以如果有特殊情况需要在未登录状态下访问Module类时，可以将方法名称命名为login。例如：**var** ret = util.remoteInvoke("CustomModule", "login", [ ] );





alert("用户名或密码错误","登录失败",modalWindow.MB_OK|modalWindow.MB_ICONINFORMATION);





```
  public boolean updateUserAttribute(String userId, String key, String value, String longValue) { 
  t_userattr
 
 this.updateUserAttribute(userId, "SYSTEM_user_isEdit", "1", (String)null);

   this.updateUserEx(userId, alias, desc, newPassword, true, (List)null);
        public boolean updateUserEx(String userId, String alias, String desc, String password, boolean isEnabled, List<? extends IExtensionAttribute> extendedAttributes) {
            return this.updateUserExtend(userId, alias, desc, password, isEnabled, extendedAttributes, false);
        }
```



```
IUser iUser = userManagerModule.getUserByName(username);
        if(iUser==null){
            return;
        }
        String userId = iUser.getId();
        userManagerModule.login("admin","manager");

         

        UserDAO userDao = UserDAO.getInstance();
        User user = (User) userDao.load(userId);
        String alias = user.getAlias();
        String desc = user.getDesc()!=null?user.getDesc():"desc text";
        String password = user.getPassword();
        
        
```



[Prepared statement returns false but row is inserted? - Stack ...](https://stackoverflow.com/questions/23088708/prepared-statement-returns-false-but-row-is-inserted)



> Returns: `true` if the first result is a `ResultSet` object; `false` if the first result is an update count or there is no result.

In this case, you got a `false` result since you executed an update operation (`INSERT` is understood as an update operation).

String uuid = UUIDGenerator.*generate*();
 String date = **new** SimpleDateFormat(**"yyyy-MM-dd hh:mm:ss"**).format(**new** Date());



```
function main(simpleReport, simpleReportContext) {
    var grid = simpleReport.grid;
    var starIndex = 1; //数据开始行，行号从0开始
    var maxRow = grid.getRowCount(); //总行数
    for (var m = starIndex; m < maxRow; m++) {
        var cellIndex = 2; //显示图片信息的列序号，序号从0开始。
        var cell = grid.getCell(m, cellIndex); //获取列
        cell.align = "center";
        var value = cell.innerText;
        if (value == 1) { //根据值不同，显示不同的图片
            cell.innerHTML = '<img src="./img/mapflag/square-star.png" />';
```



# [宏代码中如何执行SQL语句](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=52626877)

```
    var util = jsloader.resolve("freequery.common.util");
    var ret = util.remoteInvoke("DataSourceService", "getDataByQuerySql", ["FoodmartCN", "select max(f_ContactID) + 1 as t from  contacts", 0, 1000]);
    if (ret.succeeded && ret.result) {
        var data = ret.result.data;//结果集数据，返回一个二维数组
        return data[0][0].value;
    }
```





# 扩展包 to jar

由于没有内置扩展包的源码，在自定义的扩展包中无法直接引用内置扩展包中的类。

将打包好的扩展包，制作成一个普通的jar包，然后自定义扩展包添加对改jar包的依赖即可

透视分析的定制的扩展包 Insight.ext

进行解压，将里面META-INF\classes目录下的内容，全部放到扩展包根目录。

然后重新压缩，修改压缩文件后缀名为.jar。即制作好了一个内置扩展包的jar包。

将上面制作的jar文件，添加到IDEA的Libraries中。

```
最后，设置自定义扩展包依赖透视分析扩展包：打开扩展包的src\web\META-INF\extension.xml文件，添加属性depends=”Insight”（如果是其它扩展包，则填入其它扩展的名称），后续即可自由引用该内置扩展包的所有类了。
```

![img](https://jira.smartbi.com.cn:18446/resource/fckeditor/editor/filemanager/download?fdId=1706789ad18957626a9bea14f4fb659b)

![img](https://jira.smartbi.com.cn:18446/resource/fckeditor/editor/filemanager/download?fdId=1706789ad24e02d84755df740d696048)

```
let cName = elementNodeReference.className;

elementNodeReference.className = cName;
```





# .class 文件也是可以添加断点调试的





### [Mysql字符串字段判断是否包含某个字符串的方法](https://www.cnblogs.com/ericli-ericli/p/7904019.html)

```
like
SELECT * FROM users WHERE find_in_set('字符', 字段名);
SELECT find_in_set()('3','3,6,13,24,33,36') as test;

select * from 表名 where locate(字符,字段)
select * from 表名 where position(字符 in 字段);

select * from 表名 where INSTR(字段,字符)
```



可选参数

![img](https://wiki.smartbi.com.cn/download/attachments/21954843/image2016-6-29 15%3A7%3A49.png?version=1&modificationDate=1467184059000&api=v2)





# [自定义任务](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=51942031)

自定义及计划任务脚本

通过系统任务配置界面配不出来的任务，需要编写任务脚本实现

  任务脚本是在应用服务器上运行，它依赖了 [Rhino 工具包](https://developer.mozilla.org/en-US/docs/Mozilla/Projects/Rhino/Scripting_Java)，Rhino 是一种使用 Java 语言编写的 JavaScript 的开源实现，语法遵循Javascript 语法规范，能够引用 Java 类并创建 Java 对象来使用，但是并不代表可以使用 Java 语法。

脚本中还可调用如下对象：

- [系统内置对象](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=51942031#id-自定义任务-5.系统内置对象说明)：为系统内置的对象，如connector、logger对象、execute函数等。
- [SDK接口](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=51942031#id-自定义任务-6.SDK组件说明)：Smartbi服务器端SDK，共提供七项服务接口，可按需调用实现任务自定义。常用接口如打开报表、获得报表的行数等。
- [计划任务组件接口](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=51942031#id-自定义任务-7.计划任务组件说明)：为了方便用户编写自定义任务脚本，系统对常见任务进行了封装，为用户提供一些实用的组件。



#### 引入Java对象

```
//相当于: var frame = new Packages.java.io.File("filename");
 var frame = java.io.File("filename");
 
 Rhino定义了一个变量java等同于Packages.java，所以才可以省略
 new 可以被省略
 
 
 importClass (java.io.File);
var file = File("filename");

importPackage(java.io);
var file = File("filename");

在特定代码段中引用某些包
var MyImport = JavaImporter(java.io.File);
with (MyImport) {
   var myFile = File("filename");
 }
 
 
importPackage(Packages.tony);
var hello = HelloWorld();
hello.sayHello(); 
```

只有public 的成员和方法才会在JavaScript中可见。对于非public的成员，例如对 hello.sayHello()的引用将得到undefined。



任务配置界面配置的任务 查看运行脚本 基于这个脚本改成实际的需求

如自定义导出文件的名字，批量发送邮件之类

 **系统内置对象说明：**

| **对象**  | **对象描述**                                                 |
| --------- | ------------------------------------------------------------ |
| connector | 系统内置的连接对象，连接到计划任务服务器，可直接使用。例如：[在SDK对象中调用](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=51942031#id-自定义任务-SDK对象调用)： **var** tempReport = **new** Report(connector);                                            [在计划任务组件中调用](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=51942031#id-自定义任务-计划任务组件说明)：     **var** tempResourceHandle = execute("openResource", {   clientConnector: connector,   reportId: "xxxxxxxxxxx"   });                                                                                                   调用扩展包中的module方法，这样逻辑复杂可以考虑写在扩展包，计划任务直接调用： connector.remoteInvoke("CustomModule", "syncLDAPUsers", []); //后面中括号是参数,有的话就传,没有的话就是个空数组 |
| logger    | 系统内置的写日志对象。有三个方法：logger.debuglogger.errorlogger.info |
| execute   | execute函数用于执行内置计划任务组件，一般可以通过任务配置界面配置，然后查看运行脚本看execute的示例，详见[计划任务组件说明](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=51942031#id-自定义任务-计划任务组件说明)。 |

   Smartbi服务器端SDK通过JAVA API提供七项服务接口，可以在自定义任务中调用这些API。

| **服务对象**          | **描述**                                                     |
| --------------------- | ------------------------------------------------------------ |
| AnalysisReportService | 提供多维分析相关操作功能                                     |
| CatalogService        | 提供资源目录树的访问功能等                                   |
| GraphicReportService  | 提供图形分析报表访问功能                                     |
| ManageReportService   | 提供业务报表相关操作功能                                     |
| UserManagerService    | 提供用户相关操作。包括：读取/维护用户信息、读取/维护组信息、读取/维护角色信息、为用户和组分配角色等 |

具体的方法以及帮助请参考《**[JAVA API文档](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=52628009)**》

   **自定义任务中常用接口：**

读取资源节点

```
var reportId = 'I2c9410a623cc37d10123cc8f90930187';
 var catalogService = new CatalogService(connector);
 var reportElem = catalogService.getCatalogElementById(reportId);
 var reportAlias = reportElem.getAlias();
```

创建资源定义

```
var tempReport = new SSReport(connector);
tempReport.open(reportId);
```

获取设置 参数

```
var paramList = tempReport.getParamList();
tempReport.setParamValue(param.id, param.value, param.displayValue);
```

 电子表格 导出时会自动刷新报表

**导出报表到本地文件**

```
//第二个参数为String类型，表示导出格式，支持格式为PDF、PNG、WORD、EXCEL、EXCEL2007、HTML； 
tempReport.export('EXCEL', outputStream);
```



- **connector**：连接对象，为系统内置对象，无需创建可直接使用。

- **clientId**：String字符串类型，指报表的句柄ID。

- **reportId**：String字符串类型，指报表资源的唯一标识ID。

- **reportName**：String字符串类型，指报表资源的名称。

- **pageId**：String字符串类型，指页面资源的唯一标识ID。

- **param.id**, **param.value**, **param.displayValue**：String字符串类型，分别指参数ID、参数真实值、参数显示值。

- ```
  outputStream：OutputStream文件流类型，指输出文件流。
  ```



示例1、输出总行数

```
// 导入将会使用的java类与java包
 importClass(java.lang.System);
 importPackage(Packages.smartbi.sdk.service.simplereport);
  
 // 创建分析查询对象
 var reportId = 'I2c949e8e1ac2d5e6011ac380971301b8';
 var tempReportService = new SimpleReportService(connector);
 var tempReport = tempReportService.openReport(reportId);
 // 执行分析报表，获取总行数
 var totalRow = tempReport. execute(100);
 tempReport.close();
  
 logger.info('总行数为: '+ totalRow);
```



sdk API比较底层和基本、粒度比较细，往往需要多步调用才能完成一个常规操作。
为了方便用户编写自定义任务脚本，系统对常见任务进行了封装，为用户提供一些实用的组件。一般内置组件都会有对应的任务配置界面，然后【查看运行脚本】看对应组件的示例。



**内置组件**

输入参数Input、输出结果Ouput、执行方法execute。

OpenResource和ExportResource支持的资源类型包括：灵活分析、仪表分析、多维报表、门户页面。



**OpenResource** 
 打开资源组件，可以打开任意组件类型。

- connector：客户端连接对象。
- reportId：String类型，报表资源的ID。

输出结果

resourceHandle：资源句柄。



**EnumerateParamValues** 
 参数枚举组件。 设置报表参数。 

- resourceHandle：系统连接对象。
- byEveryParam：boolean类型，是否枚举true/flase。
- paramsSetting：IParamValue[]，参数缺省值。

getParamValues：获得参数枚举值的迭代器。



**FillData** 
 填充数据组件。
数据源 临时表空间 填充数据。临时空间存放较大数据，方便逻辑计算。







**ExportResource** 
 导出资源组件。 根据输入的参数迭代器，可以导出一份或多份参数组合的报表执行结果。



**SendToFile** 
 发送到文件组件。

```
    file：File[]类型，要发送的文件。
    sendSetting：ICopySetting类型，发送设置。
        filename：String类型，目标文件名。
        path：String类型，目录路径。
```

输出：无



**SendToMail** 
 发邮件组件。

```
connector：客户端连接对象。
files：File[]类型，要发送的邮件附件列表。
paramValueMap：String类型，参数值。
sendSetting：IMailSetting类型，发邮件设置信息。
...
```

 示例： "打开分析报表，枚举"产品目录参数"参数，以Excel格式导出文件至C:/task/目录"。

```javascript
//初始化参数设置：枚举"产品目录参数"，固定"开始日期"和"结束日期"参数值。
 var reportParamSetting = [
 {id:"OutputParameter.I2c90903e114ef1af01114f2ed1e40097.产品目录参数", value:"$枚举值$",displayValue:"$枚举值$"},
 {id:"OutputParameter.I2c90903e114ef1af01114f2ed1e40097.开始日期", value:"1996-01-17",displayValue:"1996-01-17"},
 {id:"OutputParameter.I2c90903e114ef1af01114f2ed1e40097.结束日期", value:"2011-03-03",displayValue:"2011-03-03"}
 ];
  
 //打开报表资源。
 var tempResourceHandle = execute("openResource", {
 connector: connector,
 reportId: "I2c90903e114f6f9601114f70e09d000e"
 });
  
 //设置报表参数。
 var enumerateParamValuesOutput = execute('enumerateParamValues', {
 resourceHandle: tempResourceHandle.resourceHandle,
 byEveryParam: true,
 paramsSetting: reportParamSetting
 });
  
 //以EXCEL格式导出报表资源。
 var exportReportOutput = execute('exportResource', {
 connector: connector,
 resourceHandle: tempResourceHandle.resourceHandle,
 paramSettingIterator: enumerateParamValuesOutput.getParamValues(),
 exportSetting: {"delimiter":"", "pathId":""},
 taskName: taskName,
 exportType: "EXCEL"
 });
  
 //输出文件到C:/task/目录。
 var outputFile = exportReportOutput.folder;
 var sendToFileOutput = execute('sendToFile', {
 file: outputFile,
 sendSetting: {path: 'C:/task/'}
 });
```



示例 发送电子表格邮件

（1） 网页版邮箱 部分格式不兼容，推荐使用foxmail

（2）电子表格必须是纯表格（文本），不能存在图形，如果存在图形或其他非文本内容会存在发送的正文存在问题；

（3）不支持有多个sheet 页的电子表格。

上述场景建议考虑使用导出图片的方式。





qq smtp 授权码 lstaudbutasfbahi

 smtp.qq.com



# Java数据集



Java数据源是指由用户通过二次开发，编写JavaQueryData接口实现类，以实现自定义数据结构的一类数据源。

没有一个物理的数据库存储其字段和数据。但它可以通过类将任意一个含有数据的文件或报表通过解析后，运用到Smartbi中。

Java数据源等同于一个分类目录节点，用于存储Java数据集对象

![img](https://wiki.smartbi.com.cn/download/attachments/44500331/image2019-7-27 15%3A16%3A43.png?version=1&modificationDate=1564211803000&api=v2)



新建Java数据集对象即是配置自定义类名和获取参数与结果集的过程。



[自定义javabean示例](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=35751454)



 apache httpClient4.5

```
 
package com.powerX.httpClient;
import java.io.IOException;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import org.apache.http.HttpEntity;
import org.apache.http.NameValuePair;
import org.apache.http.client.ClientProtocolException;
import org.apache.http.client.config.RequestConfig;
import org.apache.http.client.entity.UrlEncodedFormEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.message.BasicNameValuePair;
import org.apache.http.util.EntityUtils;
public class HttpClient4 {
    public static String doGet(String url) {
        CloseableHttpClient httpClient = null;
        CloseableHttpResponse response = null;
        String result = "";
        try {
            // 通过址默认配置创建一个httpClient实例
            httpClient = HttpClients.createDefault();
            // 创建httpGet远程连接实例
            HttpGet httpGet = new HttpGet(url);
            // 设置请求头信息，鉴权
            httpGet.setHeader("Authorization", "Bearer da3efcbf-0845-4fe3-8aba-ee040be542c0");
            // 设置配置请求参数
            RequestConfig requestConfig = RequestConfig.custom().setConnectTimeout(35000)// 连接主机服务超时时间
                    .setConnectionRequestTimeout(35000)// 请求超时时间
                    .setSocketTimeout(60000)// 数据读取超时时间
                    .build();
            // 为httpGet实例设置配置
            httpGet.setConfig(requestConfig);
            // 执行get请求得到返回对象
            response = httpClient.execute(httpGet);
            // 通过返回对象获取返回数据
            HttpEntity entity = response.getEntity();
            // 通过EntityUtils中的toString方法将结果转换为字符串
            result = EntityUtils.toString(entity);
        } catch (ClientProtocolException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 关闭资源
            if (null != response) {
                try {
                    response.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (null != httpClient) {
                try {
                    httpClient.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        return result;
    }
    public static String doPost(String url, Map<String, Object> paramMap) {
        CloseableHttpClient httpClient = null;
        CloseableHttpResponse httpResponse = null;
        String result = "";
        // 创建httpClient实例
        httpClient = HttpClients.createDefault();
        // 创建httpPost远程连接实例
        HttpPost httpPost = new HttpPost(url);
        // 配置请求参数实例
        RequestConfig requestConfig = RequestConfig.custom().setConnectTimeout(35000)// 设置连接主机服务超时时间
                .setConnectionRequestTimeout(35000)// 设置连接请求超时时间
                .setSocketTimeout(60000)// 设置读取数据连接超时时间
                .build();
        // 为httpPost实例设置配置
        httpPost.setConfig(requestConfig);
        // 设置请求头
        httpPost.addHeader("Content-Type", "application/x-www-form-urlencoded");
        // 封装post请求参数
        if (null != paramMap && paramMap.size() > 0) {
            List<NameValuePair> nvps = new ArrayList<NameValuePair>();
            // 通过map集成entrySet方法获取entity
            Set<Entry<String, Object>> entrySet = paramMap.entrySet();
            // 循环遍历，获取迭代器
            Iterator<Entry<String, Object>> iterator = entrySet.iterator();
            while (iterator.hasNext()) {
                Entry<String, Object> mapEntry = iterator.next();
                nvps.add(new BasicNameValuePair(mapEntry.getKey(), mapEntry.getValue().toString()));
            }
            // 为httpPost设置封装好的请求参数
            try {
                httpPost.setEntity(new UrlEncodedFormEntity(nvps, "UTF-8"));
            } catch (UnsupportedEncodingException e) {
                e.printStackTrace();
            }
        }
        try {
            // httpClient对象执行post请求,并返回响应参数对象
            httpResponse = httpClient.execute(httpPost);
            // 从响应对象中获取响应内容
            HttpEntity entity = httpResponse.getEntity();
            result = EntityUtils.toString(entity);
        } catch (ClientProtocolException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            // 关闭资源
            if (null != httpResponse) {
                try {
                    httpResponse.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (null != httpClient) {
                try {
                    httpClient.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
        return result;
    }
} 

```



# 系统集成 				 		    	 		         			

单点登录（Single Sign On）

在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。

![img](https://cdn.jsdelivr.net/gh/k2easy/picgo/2020/10/1420201014175902.png)

1）当用户第一次访问【应用系统1】的时候，因为还没有登录，会被引导到认证系统中进行登录；

2）根据用户提供的登录信息，认证系统进行身份效验，如果通过效验，应该返回给用户一个认证的凭据ticket；

3）用户再访问别的应用系统（【应用系统2】和【应用系统3】）的时候，就会将这个ticket带上，作为自己认证的凭据，应用系统接受到请求之后会把ticket送到【认证系统】进行效验，检查ticket的合法性。

如果通过校验，用户就可以在不用再次登录的情况下访问【应用系统2】和【应用系统3】了。



Web端：/vision/index.jsp

旧版移动端：/vision/mobileportal.jsp

新版移动端：/vision/mobileX

报表集成：/vision/openresource.jsp

功能集成（打开功能模块）：/vision/openmodule.jsp

创建资源的功能模块：/vision/createresource.jsp

**第三方系统集成Smartbi系统的核心思路**

步骤1：先想办法登录Smartbi系统。（这是集成Smartbi的前提条件）

步骤2：再根据客户的业务要求跳转到Smartbi系统中对应的集成URL链接。



登录Smartbi系统一般会有两种方式，一种是走登录验证类的方式，另一种是强制登录的方式，

登录验证类接口（[IAuthentication](http://wiki.smartbi.com.cn/api/userauthorizationapi/smartbi/usermanager/auth/IAuthentication.html)）是Smartbi系统对外提供的，可以修改Smartbi系统内部用户密码验证方式的一个接口。



Smartbi登录首页登录的时候,
Word/Excel/PPT插件登录的时候
 Smartbi移动端APP登录首页登录的时候
**都会走登录验证类的方法:** 

![img](https://cdn.jsdelivr.net/gh/k2easy/picgo/2020/10/1420201014180539.png) [与第三方系统用户集成](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=35750896)

1） 先经过config()方法，初始化一些配置，通常不需要重写。

2） 然后执行shallUserValidateInAuthentication()方法，判断是走原来smartbi的验证逻辑还是走当前登录验证类中的验证逻辑。

3） 最后再执行isPasswordValidate()方法，用来验证用户信息的正确性，若验证通过返回true，若验证不通过返回false；

4） changePassword()方法，在修改密码的时候执行。



什么情况下需要重写登录验证类：客户对自己公司平台所有系统都有要求，用户信息验证必须走公司系统登录的用户验证规范验证登录。 
常见的验证方式：AD域登录认证、CAS统一认证



### 强制登录方式

强制登录是Smartbi系统对外提供的不需要密码验证即可强制登录Smartbi系统 
1、不知道bi账户密码，跳转到bi直接进入

2、第三方系统不想使用Smartbi系统原有的认证方式，要求Smartbi系统调用他们提供的验证接口做用户信息的验证。

3、对用户的验证没有其他要求，但是不能明文传输密码或者用户名，此时我们也会第三方系统约定使用同一种加密方式（常用的有MD5或者DES）对用户名和一些关键信息进行加密，解密验证通过后，获取到用户信息，然后单点登录到Smartbi系统。

**关键工作：**

1） 获取到登录用户的信息。（得到登录的用户名）

2） 验证登录用户的合法性。（需要验证在第三方系统的合法性和在Smartbi系统的合法性）

![img](https://cdn.jsdelivr.net/gh/k2easy/picgo/2020/10/1420201014181540.png)

#### 惯用的集成方案

步骤1：Smartbi扩展包根据客户的业务需求重新封装系统集成、资源集成和模块集成的接口。（例如：ssologin.jsp、openreport.jsp、opensmartbimodule.jsp等等）

步骤2：扩展包中新建对应的过滤器（Filter）拦截对应的集成链接请求，先在Filter中获取登录用户的信息和完成用户信息的验证。

步骤3：在Filter中验证用户信息合法之后，强制登录Smartbi系统。

步骤4：在Filter中强制登录Smartbi系统后，再根据业务集成请求，打开Smartbi中对应的URL内容链接



#### 案例

客户OA系统单点登录到SmartBI系统，并且想把Smartbi的报表集成到他们的系统当中

定制开发 给第三方系统做单点登录的singallogin.jsp页面

定制一个给第三方系统做一个用于资源集成的openreport.jsp页面

```
http://ip:port/smartbi/vision/singallogin.jsp?token=URLEncode(MD5(username+datetime+MD5key))&username=xxxx&datetime=yyyyMMddHHmmss
 
用户名（username 这个用户必须在SMARTBI系统中存在
时间戳datetime（yyyyMMddHHmmss）
双方约定的密钥（MD5key）,SMARTBI这边会做成系统选项的形式，【系统选项】--【公共设置】-- 单点登录加密密钥
token = MD5(username+datetime+MD5key)

 
```

 SmartBI这边接收请求后，获得username、datetime、token信息后，一、首先通过时间戳，验证访问的URL是否已经超时，若超时，则跳转到错误提示页面提示“URL链接不可用”。二、然后再检测当前访问的用户（username），若用户不存在，则跳转到提示页面提示“用户不存在”；若用户在smartbi系统中存在，则将用户名、时间戳和约定的密钥（MD5key）做MD5加密得到新的MD5加密串，然后跟token比对，如果一致，则用该用户登录SMARTBI系统，否则跳转到错误提示页面。

```
http://ip:port/smartbi/vision/openreport.jsp?token=URLEncode(MD5(username+datetime+MD5key))&username=xxxx&datetime=yyyyMMddHHmmss&resid=报表ID

&paramsInfo=[{“name”:”参数名称1”,”value”:”真实值1”,”displayValue”:”显示值1”},{“name”:”参数名称2”,”value”:”真实值2”,”displayValue”:”显示值2”}]
```



**用户/用户组/角色同步到Smartbi系统**

一种是直接从客户提供的用户相关是数据库信息表中获取；另一种通过调用客户提供的接口获取。
当用户量比较少的时候（小于5000个）可考虑通过调用产品的API接口创建用户、用户组和角色等信息；当用户量比较大（大于5000个）可考虑直接插入数据库的方式创建；





在扩展包项目中新建一个Java类 com.mycomp.mypackage.MyAuth，并且实现接口 [IAuthentication](http://wiki.smartbi.com.cn/api/userauthorizationapi/smartbi/usermanager/auth/IAuthentication.html)；可参考自定义登录验证扩展包： [MyAuth.rar](https://wiki.smartbi.com.cn/download/attachments/51943166/MyAuth.rar?version=1&modificationDate=1595314314000&api=v2)

config.jsp 修改**加密类型**为"**CLASS**"；修改**登录验证类**为MyAuth类的全名com.mycomp.mypackage.MyAuth。



```java
for ( String uri : anonURIs ) {
    if ( ... ) {
        chain.doFilter( ... );
        return;
    }
}
```





idea, editor,file types> javascript> 添加 .js.patch 文件语法

```
操作用户可参考：smartbi .usermanager .UserManagerModule，smartbi .usermanager .User，smartbi .usermanager .UserDAO
```

UserBO

```
 UserBO userBO = UserManager.getInstance().getUserById(userId);
  private void setEnabled(String enabled) {
        this.user.setEnabled(enabled);
    }

UserDAO.getInstance().update(this.user);  


```









```
 public List<GroupAttribute> getByGroup(String groupId) {
        return this.findByNamedQuery("GroupConfig.getByGroup", new Object[]{groupId});
    }
    
    
  package smartbi.usermanager;
    @NamedQueries({@NamedQuery(
    name = "GroupExp.getInfoByUserid",
    query = "from GroupExp where userid = ? and groupid = ? and type = ?"
), @NamedQuery(
    name = "GroupExp.deleteByUserid",
    query = "delete from GroupExp where userid = ? and type = ?"
)})
@JSONFields(
    fields = {"id", "groupid", "userid", "type", "operate"}
)
public class GroupExp implements IGroupExp {

public class GroupExpDAO extends AbstractDAO<GroupExp, String> {
    private static GroupExpDAO instance = new GroupExpDAO();

    public static GroupExpDAO getInstance() {
        return instance;
    }

    GroupExpDAO() {
        super(UserManagerModule.getInstance().getDaoModule());
    }

    public void deleteByUserid(String userid) {
        this.executeNamedQuery("GroupExp.deleteByUserid", new Object[]{userid, "DATALIMIT"});
    }
    

```



#### org.hibernate.hql.ast.QuerySyntaxException is not mapped异常

这一般是HQL语句错误  
 因为Hibernate是对类查询的 ,而不是对数据库表进行查询，from是实体类而不是表名！ 
 例如： 
 String hql = “from Employee e where e.salay=? and e.email=?”;

**Employee是实体类而不是表名！**

```
@Entity
@Table(
    name = "t_group"
)
@Cache(
    usage = CacheConcurrencyStrategy.READ_WRITE,
    region = "POJO"
)
@NamedQueries({@NamedQuery(
    name = "Group.getRoot",
    query = "from Group g where g.parentGroup is null"
), @NamedQuery(
    name = "Group.getByName",
    query = "from Group g where g.name = ?"
), @NamedQuery(
    name = "Group.getByAlias",
    query = "from Group g where g.alias = ?"
), @NamedQuery(
    name = "Group.getByCode",
    query = "from Group g where g.orgId = ?"
), @NamedQuery(
    name = "Group.getByParentGroup",
    query = "from Group g where g.parentGroup = ?"
), @NamedQuery(
    name = "Group.search",
    query = "from Group g where g.name like ? or g.alias like ? or g.orgId = ?"
)})
@JSONFields(
    fields = {"id", "name", "alias", "desc", "departmentCode"}
)
public class Group implements IGroup, IDepartment, Serializable {
```

 expecting OPEN, found ','

```
query="update LoginWrongCountObject t set t.count= 1 + t.count where name =? "
别名

unexpected token: values

INSERT INTO Entity properties_list select_statement.

sessionFactory.getCurrentSession()
  .createSQLQuery("update table set field = 1 where id = :id")
  .setParameter("id", someId)
  .executeUpdate();
  
     Criteria cr = HibernateUtil.currentSession().createCriteria(MyfavoriteNode.class);
     
```

字段名称不能使用 count time这类关键词

```

        GroupToUser gtu = new GroupToUser();
        gtu.setId(UUIDGenerator.generate());
        gtu.setUser(this.user);
        gtu.setGroup(group);
        gtu.setDefault(false);
        ((List)uList).add(gtu);
        GroupToUserDAO.getInstance().save(gtu);
        ((List)list).add(gtu);
        this.user.setGroupToUserList((List)list);
        UserDAO.getInstance().update(this.user);
        GroupDAO.getInstance().update(group);
        
        UserBO.class
        
        
        /*        String hql = "insert into t_ext_user_login_wrong_count(c_id,c_name,c_count,c_time) values() ";
        Query query = (Query)this.daoModule.createQuery(hql);
        query.executeUpdate();*/
        
        query.executeUpdate(); for a select query. Try using query.list(), or query.uniqueResult() instead.
```





```
        StringBuilder _sql = new StringBuilder();
        _sql.append(" insert into  `t_ext_enable_user_record`(c_id,c_name,c_reason,c_time) values( ");
        _sql.append(" '"+uuid+"', ");
        _sql.append(" '"+username+"', ");
        _sql.append(" '"+reason+"', ");
        _sql.append(" '"+date+"' ");
        _sql.append(" ) ");
        String sql = _sql.toString();

        UserManagerModule userMa       nagerModule = UserManagerModule.getInstance();
        IConnectionInfo info = userManagerModule.getDaoModule().getRepository().getConnectionInfo();
        Connection conn = null;
        PreparedStatement prep = null;
        boolean rs = false;
        try {
            conn = ConnectionPool.getInstance().getConnection(info);
            prep = conn.prepareStatement(sql);
            rs  = prep.execute(sql);
            prep.close();
            conn.close();
            rs = true;
        } catch (Exception var13) {
            log.error( " enableUser : ", var13);
        }
        return rs ;
```





# 宏代码中如何执行SQL语句

我们在开发宏代码的过程中，有时候会遇到一些比较复杂的需求，比如根据后台数据库表中的某个状态位执行不同的处理逻辑。或者求一个汇总值显示在图形和地图上。这类需求通常都需要在宏代码中执行一段SQL语句，获取其结果值。那么如何在宏代码中如何执行SQL语句呢，请参考以下说明。

**1****、执行SQL****语句的方法**

在客户端宏代码中，通过调用服务端DataSourceService类中的getDataByQuerySql等方法，可以执行SQL语句，然后根据返回值获取相应的SQL结果集。示例代码如下。

/**

 \* 执行SQL语句，获取结果集

 */

function getSqlResult() {

  var util = jsloader.resolve("freequery.common.util");

  var ret = util.remoteInvoke("DataSourceService", "getDataByQuerySql", ["DS.数据源名称", "select 100 as t from dual", 0, 1000]);

  if (ret.succeeded && ret.result) {

​    var data = ret.result.data;

​    return data;

  }

};

 

**2****、DataSourceService****类中方法列表**

DataSourceService类中可以被客户端宏代码中调用的方法有getDataByQuerySql、execute、executeNoCacheable、executeUpdate等。每个方法的签名信息如下。

/**

​       \* 获取未格式化的原始的结果集数据。

​       \* 

​       \* @param dsId 数据源ID值

​       \* @param sql 待执行SQL语句

​       \* @param pageNum 获取结果集中的页数

​       \* @param rowPerPage 分页显示每页行数

​       \* @return SQL执行的结果集

​       */

​      public GridData getDataByQuerySql(String dsId, String sql, int pageNum, int rowPerPage);

​      

​      /**

​       \* 执行指定SQL语句，返回相应结果集。该函数主要是为了在前端宏代码中调用。

​       \* @param dataSourceID 数据源ID值。

​       \* @param sql 待执行SQL语句。

​       \* @param maxRows 返回的最大记录数。

​       \* @param format 是否对结果集格式化。

​       \* @param cacheable 是否从缓存中返回结果集。

​       \* @return 返回SQL执行后的结果集。

​       */

​      public GridData execute(String dataSourceID, String sql, int maxRows, boolean format, boolean cacheable);

​      

​      /**

​       \* 直接执行指定SQL语句，返回相应结果集，不从缓存中返回结果集。该函数主要是为了在前端宏代码中调用。

​       \* @param dataSourceID 数据源ID值。

​       \* @param sql 待执行SQL语句。

​       \* @return 返回SQL执行后的结果集。

​       */

​      public GridData executeNoCacheable(String dataSourceID, String sql);

​      

​      /**

​       \* 直接执行SQL语句，可以是INSERT, UPDATE, DELETE语句，也可以是SQL DDL语句。该函数主要是为了在前端宏代码中调用。

​       *

​       \* @param dataSourceID 数据源ID。

​       \* @param sql 待执行的SQL语句。

​       \* @return either (1) the row count for SQL Data Manipulation Language (DML) statements or (2) 0 for SQL statements that return nothing

​       */

​      public int executeUpdate(String dataSourceID, String sql);

 

上述方法返回值的说明：

对于返回int等标量类型的，可以从ret.result属性中获取。

对于返回GridData对象的，可以利用ret.result.data属性获取到结果集的二维数组。数组中是CellData对象，其有如下属性：value、displayValue、stringValue、intValue、longValue、doubleValue、dateValue等。

  

# office插件

C:\Smartbi\Tomcat\webapps\smartbi\app\SmartbiOfficeAddin9.5.exe

# 电子表格开发

```
左父格	设置单元格间的父子关系，子格会随着左父格上下扩展。
上父格	设置单元格间的父子关系，子格会随着上父格左右扩展。



区域 设置数据区。
过滤	用于数据字段的结果集的筛选。
格式	设置单元格的特殊格式，包含“金额、图片、二维码、斜线、文件、清空格式”。
属性	设置单元格属性，包含“扩展、附属、分页属性”。
引用参数	指在单元格中获取当前报表参数的值，当切换参数值时，引用参数的单元格数据会跟随变化。
参数排版	指对带参数的电子表格中的参数在浏览端的布局样式进行排版。
默认参数	指对电子表格中的参数设置默认值。

填报列表	填报列表列出当前sheet页的所有单元格的填报属性。
填报属性	设置单元格是否可以执行修改、插入/删除行等操作。

单元格传值
传值	在查看报表时希望能看到数据的其他信息，并在报表中显示出来，这时我们可以使用单元格传值功能。
管理	管理指列出当前电子表格的传值单元格，可对其进行编辑。
```



## 页面设置

表头表尾固定仅支持上下标题、左右标题
表格居中显示。，禁用图表鼠标提示 
背景图 拉伸。 平铺保持原本大小

对报表水印的设置，页面设置比系统选项的优先级更高。
水印模式为“融入背景图”，当导出/打印该电子表格时，水印保留。
 电子表格报表会遮挡水印。

水印模式为“前端渲染”时，电子表格报表不会遮挡水印。当导出/打印电子表格时，水印不支持导出/打印。1、水印模式为“前端渲染”时，必须是完整的水印才会显示。如当识别到报表的有效单元格位置太少，导致位置放不下水印，则不显示水印。

2、空的Sheet页不显示水印。

工具栏设置
工具栏整体设置和Sheet页标签设置
![img](https://cdn.jsdelivr.net/gh/k2easy/picgo/2020/10/3020201030111251.png)



excel中的echarts图表支持更改
选中电子表格报表设计区的图形，点击工具栏 **更改** 按钮，弹出“更改图表”界面，选择图表模板。

插入	 
表示从绑定字段单元格为起始，每扩展出一行或一列数据，就新插入一行或一列用于填充这些数据展现。覆盖 不创建新行列，覆盖即可 。
我们在绑定字段的单元格后一行添加橙色底色进行标识，可
以发现该橙色行一直被插入的行或列往后推移，没有被字段扩展的内容填充。

<img src="https://wiki.smartbi.com.cn/download/attachments/44501776/image2019-7-29 10%3A12%3A42.png?version=1&modificationDate=1564366358000&api=v2" alt="img" style="zoom:50%;" />

![img](https://wiki.smartbi.com.cn/download/attachments/44501776/image2018-12-21 13%3A56%3A21.png?version=1&modificationDate=1556967168000&api=v2)



扩展方向：不扩展 ，将所有扩展出来的内容集中显示在一个单元格中。场景：数值内容）进行汇总、平均值、计数等计算。

![img](https://wiki.smartbi.com.cn/download/attachments/44501776/image2019-7-20 17%3A24%3A4.png?version=1&modificationDate=1563614642000&api=v2)

单元格属性：延伸
![image-20201030132411405](https://cdn.jsdelivr.net/gh/k2easy/picgo/2020/10/3020201030132411.png)

左父格：表示以左侧具有扩展属性的单元格为父格。

上父格：表示以上方具有扩展属性的单元格为父格。

![image-20201030135116794](/Users/demo/Library/Application%20Support/typora-user-images/image-20201030135116794.png)

父格：
无：表示没有父格，只有当子格左方或者上方有扩展属性的单元格，又不想子格进行扩展时，需要将子格设置成“无”。
默认：表示按照系统默认的寻找父格方式设置父格。
自定义：表示以用户指定的单元格为父格。

### 数据设置

分组：以父格内容作为分组依据：内容相同的行或列为一组，且父格以多行或多列合并显示。
汇总：将扩展出来的内容进行聚合方式计算，该项只针对“不扩展”而言，且只对数字列有意义。

分组 默认：
将原始数据表中所有属于当前父格内容的子格集中显示。

![img](https://wiki.smartbi.com.cn/download/thumbnails/44501777/image2019-1-17 14%3A53%3A55.png?version=1&modificationDate=1556967298000&api=v2)

分组 自定义：

![img](https://wiki.smartbi.com.cn/download/thumbnails/44501777/image2019-1-17 15%3A2%3A46.png?version=1&modificationDate=1556967288000&api=v2)

<img src="https://wiki.smartbi.com.cn/download/attachments/44501777/image2019-7-22 13%3A48%3A35.png?version=1&modificationDate=1563774516000&api=v2" alt="img" style="zoom:50%;" />

![img](https://wiki.smartbi.com.cn/download/attachments/44501777/image2019-7-22%2013%3A46%3A48.png?version=1&modificationDate=1563774409000&api=v2)

分组：连续：
按照原始数据顺序，将属于当前父格内容的连续的或单个的子格分组显示，若再次出现该父格内容则再新分一个组显示。

![img](https://wiki.smartbi.com.cn/download/thumbnails/44501777/image2019-1-17 15%3A2%3A46.png?version=1&modificationDate=1556967288000&api=v2)

汇总：

<img src="https://cdn.jsdelivr.net/gh/k2easy/picgo/2020/10/3020201030142219.png" alt="image-20201030142219693" style="zoom:50%;" />



# 参数控件 

下拉框
选中要插入控件的单元格，在工具栏中选择 **下拉框** 控件
拖拽控件选中状态下的四周显示的圆圈，用于调整控件的大小

![img](https://wiki.smartbi.com.cn/download/attachments/44501782/image2019-7-22 13%3A59%3A34.png?version=1&modificationDate=1563775175000&api=v2)



## 冻结行头

冻结首列
切换到“视图”分类页，点击 **冻结窗口 > 冻结首列** 即可，如图：

冻结任意几列
1、选中所要冻结列的下一列，切换到“视图”分类页，点击 **冻结窗口 > 冻结拆分窗格** 即可，如

![img](https://wiki.smartbi.com.cn/download/attachments/44501790/image2019-1-15 11%3A21%3A34.png?version=1&modificationDate=1556968305000&api=v2)

![img](https://wiki.smartbi.com.cn/download/attachments/44501790/dongjiehangtou.gif?version=1&modificationDate=1556968300000&api=v2)



### 数据区

![img](https://wiki.smartbi.com.cn/download/attachments/44501792/image2019-1-15 16%3A22%3A33.png?version=1&modificationDate=1556968362000&api=v2)



![img](https://wiki.smartbi.com.cn/download/attachments/44501793/image2019-1-16 11%3A0%3A48.png?version=1&modificationDate=1556968375000&api=v2)

![img](https://wiki.smartbi.com.cn/download/attachments/44501793/image2019-1-16 11%3A2%3A19.png?version=1&modificationDate=1556968372000&api=v2)



插入图片
![img](https://wiki.smartbi.com.cn/download/attachments/44501797/image2019-7-22 16%3A45%3A13.png?version=1&modificationDate=1563785114000&api=v2)

![img](https://wiki.smartbi.com.cn/download/attachments/44501797/image2019-1-16 15%3A12%3A47.png?version=1&modificationDate=1556968524000&api=v2)



数据条
![img](https://wiki.smartbi.com.cn/download/attachments/44501799/image2019-1-21 10%3A34%3A25.png?version=1&modificationDate=1556968558000&api=v2)



间隔色
![img](https://wiki.smartbi.com.cn/download/attachments/44501802/image2019-1-22 15%3A11%3A6.png?version=1&modificationDate=1556968701000&api=v2)

告警： 高亮
![img](https://wiki.smartbi.com.cn/download/attachments/44501804/image2019-1-22 17%3A47%3A21.png?version=1&modificationDate=1556968737000&api=v2)

![img](https://wiki.smartbi.com.cn/download/attachments/44501804/image2019-1-22 17%3A54%3A18.png?version=1&modificationDate=1556968735000&api=v2)



## 照相机

把某些单元格或某区域的数据，使用照相机功能，把该单元格或该区域的数据生成图片，将其展示在预定的位置。

以链接的图片作为资源展示的占位符，使得电子表格的排版和布局更灵活

使用照相机功能，避免了不同单元格之间因为对不同行高列宽的需求而产生互相干扰。

1、选中需要拍照的区域，右键复制，锁定其为选中状态，如下图：

![img](https://wiki.smartbi.com.cn/download/attachments/44501809/image2019-3-4 14%3A32%3A6.png?version=1&modificationDate=1556968964000&api=v2)

2、选中预定的位置，右键菜单选择 **选择性粘贴 > 链接的图片** ，将上一步复制的内容转换成图片贴入到预定位置，如图：

![img](https://wiki.smartbi.com.cn/download/attachments/44501809/image2019-3-4 14%3A39%3A47.png?version=1&modificationDate=1556968962000&api=v2)

3、粘贴后效果如图：

1）鼠标点击图片可以自由移动其位置。

2）鼠标点击图片四周的节点可调节其形状大小。

![img](https://wiki.smartbi.com.cn/download/attachments/44501809/image2019-3-4 14%3A41%3A56.png?version=1&modificationDate=1556968959000&api=v2)



定位数据集：选中某字段，右键菜单选择 **定位数据集** ，则在右侧数据集面板的资源目录下直接定位到该字段对应的数据集的对应字段，

跳转规则：是指专门实现报表之间关联跳转功能的报表宏，例如：分析流、报表下钻等分析。



### 单元格传值

![img](https://cdn.jsdelivr.net/gh/k2easy/picgo/2020/10/3020201030154450.gif)

这里使用了两个表格，要对表格内的数据进行区域划分，否则两个表格之间会互相影响。

点击工具栏的 **区域** 按钮，弹出“数据区设置”界面，点击 **添加** 按钮，添加如图两个区域：

<img src="https://wiki.smartbi.com.cn/download/attachments/44501770/image2019-7-20 16%3A32%3A5.png?version=1&modificationDate=1563611523000&api=v2" alt="img" style="zoom:50%;" />



<img src="https://wiki.smartbi.com.cn/download/attachments/44501770/image2019-7-20 16%3A37%3A27.png?version=1&modificationDate=1563611845000&api=v2" alt="img" style="zoom:50%;" />



# 列分页

列分页无法单独设置，要勾选“列分页”必须先勾选“行分页”。

1、不支持修改数据区域。若需要修改已经设置好的数据区域，可将已设置好的数据区域删除，并重新设置。

2、在Excel中进行删除行、列时，数据区域不会自动变化，需重新设置数据区域。



分析报告
Sheet2 中创建好清单报表，复制，sheet1右键 选择行粘贴，照相机

完成图形定制后， 在右键菜单中选择 **移动或复制**；将图形移动到Sheet1中，
// 猜想：图形本身就是图片链接，可以直接复制粘贴，表格需要照相机粘贴

#### 套打报表

套打报表是指将数据按照一定的格式要求填充到固定报表的特定位置上去，便于控制精确打印的一种功能，通常用于支票、发票等的打印。

在Excel菜单 **页面布局** 中选择 **背景。**
根据套打背景来调整单元格的行高、列宽，以及合并单元格。可以先调整行高再调用列宽，最后把需要合并的单元格进行合并。

<img src="https://wiki.smartbi.com.cn/download/attachments/44501932/image2019-7-25 16%3A39%3A44.png?version=1&modificationDate=1564043982000&api=v2" alt="img" style="zoom:50%;" />



#### SQL映射表

![img](https://wiki.smartbi.com.cn/download/attachments/47494481/image2019-11-25 14%3A51%3A59.png?version=1&modificationDate=1574664722000&api=v2)

![img](https://wiki.smartbi.com.cn/download/attachments/47494481/image2019-11-25 15%3A9%3A5.png?version=1&modificationDate=1574665748000&api=v2)





\```//获取D2单元格`

```
  ``var` `td = spreadsheetReport.getCell(1, 3);
  ``//添加按钮
  ``td.innerHTML = ``"<input type='button' value='新按钮'>"``;
  ``td.firstChild.onclick = ``function``() {
    ``alert(``"添加按钮成功！"``);
  ``}
```

```
   //获取B5单元格字段扩展出来的数据
    var Pos = spreadsheetReport.getExpandedPositions("B5");
    //获取B5单元格中字段扩展出的数据的最后一行行号
    var lastRow = spreadsheetReport.parseCellIndex(Pos[Pos.length - 1])[0];
    //获取B5单元格数据下的一行，第二列的数据，从0开始计数，因此坐标为lastRow+1,1
    var td = spreadsheetReport.getCell(lastRow + 1, 1);
```



```
function main(spreadsheetReport) {
    var that = spreadsheetReport.spreadsheetReportWriteBack;
    that.__new_doSaveClick = function() {
        windowAlert("电子表格点击保存按钮触发宏事件!");
        this.doSaveClick();
    }
    that.removeListener(that.elem_btnSave, "click", that.doSaveClick, that);
    that.addListener(that.elem_btnSave, "click", that.__new_doSaveClick, that);
}
```



# 常见宏代码

 1、柱形图 高亮


    function main(chartView) {
        var biChart = chartView.getChartObject();
        var option = biChart.getOptions();


​        
​        var gridData = chartView.getGridData();
​        var data = gridData.data;
​        
​        var maxIndex=0,minIndex=0;
​        data.forEach(function(arr,i){
​            let name = arr[0].value;
​            let value = arr[1].value;
​            if(value>data[maxIndex][1].value){
​                maxIndex = i ;
​            }
​            if(value<data[minIndex][1].value){
​                minIndex=i;
​            }
​        }) 
​        
​       var optionData= option.series[0].data;
​    
​       if(optionData){  
​              optionData[maxIndex].itemStyle={
​                  normal:{
​                      borderWidth:5,
​                      borderColor:'green'
​                  }
​              }
​            optionData[minIndex].itemStyle={
​                  normal:{
​                      borderWidth:5,
​                      borderColor:'green'
​                  }
​              } 
​       }
​       
​       setTimeout(function(){
​            var eChart = biChart.getChart();
​            eChart.setOption(option)
​    
​       },0)
​       
​    }
2、柱形图 轮播 

```
function main(chartView) {
    var biChart = chartView.getChartObject();
    var option = biChart.getOptions();
    var eChart = biChart.getChart();

    var gridData = chartView.getGridData();
    var dataLen = gridData.data.length;
    var chartType = chartView.chartType;

    // highlight
    option.series[0].emphasis = {
        itemStyle: {
            color: 'red',
            borderColor: 'red'
        }
    }

    //定时轮播
    chartView.lunbo = {
        index: 0,
        howOften: 1000,
        timeTicket: null,

        startLoop: function() {
            var that = this;
            that.timeTicket = setInterval(function() { 
                //取消高亮
                eChart.dispatchAction({
                    type: 'downplay',
                    seriesIndex: 0
                });

                eChart.dispatchAction({
                    type: 'highlight',
                    seriesIndex: 0,
                    dataIndex: that.index % dataLen
                }); 
                that.index++;
            }, that.howOften)
        },

        stopLoop: function() {
            clearInterval(this.timeTicket)
        }
    }

    eChart.setOption(option);

    chartView.lunbo.startLoop();

    chartView.refresh = function(chartType, option, renew) {
        chartView.lunbo.stopLoop();
        chartView.lunbo.index = 0;
        chartView.lunbo.startLoop();
    }

    chartView.destroy = function() {
        chartView.lunbo.stopLoop();
    }
}
```



echarts地图边框阴影

```
       itemStyle: {
            normal: {
                areaColor: '#01215c',
                borderWidth: 5, 
                borderColor: '#9ffcff',
                shadowColor: 'rgba(0,54,255, 1)',
                shadowBlur: 15
            }
        }
    },
```



 [echarts 设置地图外边框以及多个geo实现缩放拖曳同步](https://blog.csdn.net/m0_37294207/article/details/96879705)

[3D地图边缘高亮](https://www.makeapie.com/editor.html?c=xrJdvs1oRx)

 [echarts 设置地图外边框、地图背景渐变色和地图阴影,增加立体感以及在地图上打点](https://www.codenong.com/cs106099547/)



参数传值

从一个参数传值到另一个参数，并能查看其数据信息的设置。

区域传值

传值到某一个区域，如某个单元格。

![img](https://wiki.smartbi.com.cn/download/attachments/49812988/image2020-2-21 16%3A37%3A16.png?version=1&modificationDate=1582274237000&api=v2)



# [原生SQL SQL查询区别](https://wiki.smartbi.com.cn/pages/viewpage.action?pageId=27001170)

**SQL查询** 

- 原理：对用户撰写的SQL进行一层包装，添加更多分析功能。
  例如客户写的是select t.x as Fa, (t.x+t.y) as Fb from T where ....
  那么封装后就变成：    
  select Fa, Fb //可以选择显示那些字段。
  from       
  (select t.x as Fa, (t.x+t.y) as Fb from T where .... ) TX       
  where .... //报表展现中，可以设置过滤条件，就是靠修改的这部分SQL实现       
  order by ....//报表展现中，排序操作，就是靠修改的这部分SQL实现       
  group by ... //报表展现中，聚合小计操作，就是靠修改的这部分SQL实现      

- 优势：在灵活分析的展现界面，还可以做排序，过滤，汇总等操作；     
- 劣势：对SQL有书写要求，需要在用户sql中，显式申明别名；对SQL做多一层封装，对于某些数据库来说，可能效率会低一些；

**原生SQL查询** 

- 原理：不对用户的SQL做任何封装，直接提交到数据库。 
- 优势：对SQL语法没有任何限制；速度更快； 
- 劣势：不计算总行数；如果查询结果较大，用户可能不知道结果集大小；在灵活分析的展现界面，不支持排序、过滤、聚合等操作；





此现象一般时因为电子表格中建跳转规则的单元格刚好被excel里的形状或者图片遮挡了，因为单元格中的文字时在最底部，而形状在文字的上方，所以就无法点击。只需要将遮挡的形状移开即可解决。

在电子表格设计器中创建电子表格，其中图形位于Sheet1，并且图形名称为“销售柱图”

在电子表格跳转源报表中，可以进行跳转并将源报表中的参数值传递给目标报表。

可以右键图片属性面板数值调整大小 取消宽高比。







首先，要明确，我们的数据集中最外层必须有select 语句，要有返回结果集。

其次，在数据集中是可以执行多条语句的，多条语句间用分号间隔开即可。

在数据集中执行存储过程，可以参考下面这种：

第一条是select语句，是这个数据集本身需要返回的数据。

第二条是执行的存储过程，需要注意的是，我们仅仅只是在数据集中执行这个存储过程而已，不会获得这个存储过程执行返回的结果。![img](https://cdn.jsdelivr.net/gh/k2easy/picgo/2020/12/1820201218095640.png)



# 宏 执行sql查询

```
function main(spreadsheetReport) {

    //每次点击保存进行一次校验

    var writeBack = spreadsheetReport.spreadsheetReportWriteBack;
    writeBack.removeListener(writeBack.elem_btnSave, "click", writeBack.doSaveClick, writeBack);
    
    //console.log($(writeBack.elem_btnSave).off('click'))
    
    var elemEventHandler = function(e) { 
            var b3 = spreadsheetReport.getCell("B3").innerText;

            var isExist = ifExistName(b3);
            console.log(isExist)
            if (isExist) {
                layer.msg('数据已经存在', {
                    icon: 2
                })
                return;
            }else{
                 this.doSaveClick(e);
            }

           
        };
            writeBack.elem_btnSave.removeEventListener("click", elemEventHandler , true);
    writeBack.addListener(writeBack.elem_btnSave, "click", elemEventHandler,   writeBack);
  
 

}

function ifExistName(name) {
    //宏代码中如何执行SQL语句
    var util = jsloader.resolve("freequery.common.util");
    var ret = util.remoteInvoke("DataSourceService", "executeNoCacheable", ["DS.test", "select distinct name  from test.tzbank1 where name is not null and length(name)>0 "]);
    if (ret.succeeded && ret.result) {
        var data = ret.result.data;
        for (var i = 0; i < data.length; i++) {
            // console.log(data[i][0].stringValue,name)
            if (data[i][0].stringValue == name) { 
                return true
            }
        }
    }
    return false
}
```





![img](https://wiki.smartbi.com.cn/download/attachments/47481469/image2019-10-29 17%3A43%3A31.png?version=1&modificationDate=1572342215000&api=v2)





跳转规则 
模版单元格没办法批量设置 B2,C2 
没办法传递常量，只能借助额外的常量单元格
传值时如果没有获取到该单元格（该单元格被服务端宏隐藏掉了，不存在），则子页面该参数显示的是空而不是默认值，{[ ]} 判断该参数为空 ，则内部表达式替换成1=1

 



![image-20210318095431315](/Users/demo/Library/Application%20Support/typora-user-images/image-20210318095431315.png)





对过滤表达式增加括号，要求同时选中2条或2条以上表达式时才能使用括号（按住Ctrl键可选择多条表达式。）





由于Excel2007自身对数据行数是有限制的，最大行数为1048576。所以系统选项里的“Excel2007最大导出行数”最大不能超过1048576。



自助ETL
自定义SQL 仅支持查询, delete , trunk,存储过程都不支持。

仅支持查询不支持字段别名





漏洞修复

# CVE-2020-15778 openssh漏洞修复

1.升级到openssh-8.4以上的版本
（要求操作系统版本在centos 8及以上）

或者 2.禁用scp命令
mv /usr/bin/scp /usr/bin/no_use_scp
然后本机执行scp或是从其他机器往本机执行scp都会提示command not found

禁用scp后可以用rsync等命令替代
————————————————
版权声明：本文为CSDN博主「N07ME」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/N07ME/article/details/111034326

tomcat 10



smartbi 缺少回收站，误删资源找回





## 新增 工具条按钮

```
function main(spreadsheetReport, spreadsheetReportContext) {
    // 在快捷工具栏上添加新按钮
    if (!spreadsheetReport.addPrint) {
        var td =spreadsheetReport.elem_btnPrint.parentNode;
        var goBtn = document.createElement('input');
        goBtn.setAttribute("type", "button");
        goBtn.className = "button-buttonbar ";
        goBtn.value = " 打印  ";
        spreadsheetReport.addListener(goBtn, "click",
        function() {
            spreadsheetReport.doPrint(true, false);
        });
        td.appendChild(goBtn);
        spreadsheetReport.addPrint = true;
    }
};
```





```sql
( SELECT KEY_FIELD_1,LOOKUP_FIELD_1  
FROM TABLE_1  
WHERE FILTER_FIELD = '1' )  
EXCEPT  
( SELECT KEY FIELD_2,LOOKUP_FIELD_2  
FROM TABLE_2 )
```

