# Resource             

来自 [《科技爱好者周刊》](https://link.zhihu.com/?target=https%3A//github.com/ruanyf/weekly)收集的免费书籍汇总推荐

[Go语言101](https://gfw.go101.org/article/101.html)

[Golang tutorial series by golangbot.com ](https://golangbot.com/learn-golang-series/)  [中文翻译版](https://www.yuque.com/ksco/golangbot-cn)

程序员精神， 快速学习应用实践 大胆尝试，开发有创意能赚钱的产品

#     [chai2010](https://github.com/chai2010)    /      **[advanced-go-programming-book](https://github.com/chai2010/advanced-go-programming-book)**

 

# 《Go101》

# 简介

Go诞生于谷歌研究院,Go的核心设计成员中包括很多有着数十年编程语言研究领域经验的研究者。
编译时间的长短是开发愉悦度的一个重要因素。 编译时间短是很多程序员喜欢Go的一个原因。
`gc(Go compiler)编译器`支持跨平台编译。 比如，我们可以在Linux平台上编译出Windows程序，反之亦然。

Go程序生成的二进制可执行文件常常拥有以下优点：

- ​	内存消耗少
- ​	执行速度快
- ​	启动快

- ​	程序编译时间短
- ​	像动态语言一样灵活
- ​	内置并发支持

Go的设计中有很多折衷和各种权衡,比如，目前Go不支持任意类型的不变量。目前Go不支持自定义范型。Go语言设计团队并不排斥自定义范型，他们只是还没有找到一个既优美又能够保持Go语法简洁性的自定义范型设计方案

# Go SDK

官方Go SDK中提供的工具是使用的最广泛的Go开发工具

请从[国际官网](https://golang.org/doc/install) golang.org 或者[国内官网](https://golang.google.cn/doc/install) golang.google.cn下载安装Go SDK

Go SDK安装目录下的`bin`子目录路径必须配置在`PATH`环境变量中。

`GOPATH`环境变量的默认值为当前用户的HOME目录下的名为`go`文件夹对应的目录。 `GOPATH`环境变量中可以指定多个目录。

`GOBIN`环境变量用来指定某些`go`子命令（比如`go install`，见下）产生的二进制可执行文件应该存储在何处。 如果此环境变量未指定，`go`命令将使用`GOPATH`环境变量中指定的第一个路径下的`bin`子目录路径来存储这些可执行文件。 此目录的路径需配置在`PATH`环境变量中，以便从任意目录运行这些可执行文件。

在Go SDK 1.11版本之前，`go`命令推荐所有的Go代码都放在`GOPATH`环境变量中指定的任一个路径下的`src`子目录中，尤其是依赖于其它第三方代码库包的Go项目代码。

从Go SDK 1.13开始，Go模块（Go modules）。 此特性让我们得以自由地将我们的Go项目代码放置在任何目录下。旧的`GOPATH`模式将不再推荐。`GOPATH`环境变量的意义和必要性将大大减弱，甚至逐渐消失。 另一方面，`GOBIN`环境变量的重要性将提升，因为我们仍需要一个目录路径用来存储某些`go`子命令产生的二进制可执行文件。

`go run test.go`
如果一个程序的`main`包中有若干Go源代码文件,可以 $ go run .来运行。

`go run`子命令只是一种方便的方式来运行简单的Go程序。 对于正式的项目，最好使用`go build`或者`go install`子命令来编译生成可执行程序文件。

`go env`命令查看Go相关环境变量设置

从Go SDK 1.11开始，如果环境变量`GO111MODULE`被设置成了`on`（可以使用`go env`命令查看Go相关环境变量设置），请在Go源码文件同目录下创建一个`go.mod`文件，其中包含一行类似于`module my.module`的指令。此文件可以使用命令`go mod init my.module`来生成。

`go run`、`go build`和`go install`） 将只会输出代码语法错误。它们不会输出可能的代码逻辑错误（即警告）。 `go vet`子命令可以用来检查可能的代码逻辑错误。

`go fmt`子命令来用同一种代码风格格式化Go代码。

`go get`子命令将一个远程Go代码库拉取到本地以便将其做为第三方Go包引入并使用其中的资源。 `go get`子命令需要首先安装相应的代码版本管理工具。

`go test`子命令来运行单元和基准测试用例

`go doc`子命令来查看Go代码库包的文档

 `go mod`子命令来管理包依赖。

`go help aSubCommand`来查看一个子命令`aSubCommand`的帮助信息

运行不带参数的`go`命令将会列出所有支持的`go`子命令。

# 入门

左大括号`{`不能被放到下一行

关键字是一些特殊的用来帮助编译器理解和解析源代码的单词。

```go
break     default      func    interface  select
case      defer        go      map        struct
chan      else         goto    package    switch
const     fallthrough  if      range      type
continue  for          import  return     var
```

25个关键字可以分为四组：

- ​	`const`、`func`、`import`、`package`、`type`和`var`用来声明各种代码元素。
- ​	`chan`、`interface`、`map`和`struct`用做 一些组合类型的字面表示中。
- ​	`break`、`case`、`continue`、`default`、`else`、`fallthrough`、`for`、`goto`、`if`、`range`、`return`、`select`和`switch`用在流程控制语句中。 详见[基本流程控制语法](https://gfw.go101.org/article/control-flows.html)。
- ​	`defer`和`go`也可以看作是流程控制关键字， 但它们有一些特殊的作用。详见[协程和延迟函数调用](https://gfw.go101.org/article/control-flows-more.html)。

### 标识符

标识符是一个以Unicode字母或者`_`开头并且完全由Unicode字母和Unicode数字组成的单词

标识符`_`是一个特殊字符，它叫做**空标识符**。

一个由[Unicode大写字母](http://www.fileformat.info/info/unicode/category/Lu/list.htm)开头的标识符称为**导出标识符**。 这里***导出\***可以被理解为***公开\***（public）。 其它（即非Unicode大写字母开头的）标识符称为**非导出标识符**。 ***非导出\***可以被理解为***私有\***（private）。 截至目前（Go 1.14），东方字符都被视为非导出字符。 

### 17种基本内置类型(预声明类型)

类型（type）可以被看作是值（value）的模板，值可以被看作是类型的实例

- ​	一种内置布尔类型：`bool`。
- ​	11种内置整数类型：`int8`、`uint8`、`int16`、`uint16`、`int32`、`uint32`、`int64`、`uint64`、`int`、`uint`和`uintptr`。
- ​	两种内置浮点数类型：`float32`和`float64`。
- ​	两种内置复数类型：`complex64`和`complex128`。
- ​	一种内置字符串类型：`string`。

Go中有两种内置类型别名（type alias）：

- ​	`byte`是`uint8`的内置别名。 我们可以将`byte`和`uint8`看作是同一个类型。
- ​	`rune`是`int32`的内置别名。 我们可以将`rune`和`int32`看作是同一个类型。

以`u`开头的整数类型称为无符号整数类型。非负。

我们使用字节（byte）做为值尺寸的度量单位。 一个字节相当于8个比特。所以`uint32`类型的尺寸为4，即每个`uint32`值占用4个字节。

`uintptr`、`int`以及`uint`类型的值的尺寸依赖于具体编译器实现。 通常地，在64位的架构上，`int`和`uint`类型的值是64位的；在32位的架构上，它们是32位的。 编译器必须保证`uintptr`类型的值的尺寸能够存下任意一个内存地址。

一个`complex64`复数值的实部和虚部都是`float32`类型的值。 一个`complex128`复数值的实部和虚部都是`float64`类型的值。

在内存中，所有的浮点数都使用[IEEE-754格式](https://en.wikipedia.org/wiki/IEEE_754)存储。

一个布尔值只有两种可能的状态。 这两种状态使用两个预声明（或称为内置）的常量（`false`和`true`）来表示

一个字符串值表示一段文本。 在内存中，一个字符串存储为一个字节（byte）序列。 此字节序列体现了此字符串所表示的文本的UTF-8编码形式。

### 零值

每种类型都有一个零值。一个类型的零值可以看作是此类型的默认值。

- ​	一个布尔类型的零值表示真假中的假。
- ​	数值类型的零值都是零（但是不同类型的零在内存中占用的空间可能不同）。
- ​	一个字符串类型的零值是一个空字符串。

### 基本类型的字面量表示形式

一个值的字面形式称为一个字面量，它表示此值在代码中文字体现形式（和内存中的表现形式相对应）。一个值可能会有很多种字面量形式。 

#### 布尔值的字面量形式

我们可以将`false`和`true`这两个预声明的有名常量当作布尔类型的字面量形式。 但是，我们应该知道，从严格意义上说，它们不属于字面量。有名常量声明

#### 整数类型值的字面量形式

十进制形式（decimal）、八进制形式（octal）、十六进制形式（hex）和二进制形式（binary）

```go
0xF // 十六进制表示（必须使用0x或者0X开头）
0XF

017 // 八进制表示（必须使用0、0o或者0O开头）
0o17
0O17

0b1111 // 二进制表示（必须使用0b或者0B开头）
0B

15  // 十进制表示（必须不能用0开头）
```

```go
println(15 == 017) // true
```

#### 浮点数类型值的字面量形式

十进制浮点数文字表示

一个浮点数的完整字面量形式包含一个十进制整数部分、一个小数点、一个十进制小数部分和一个整数指数部分。常常地，某些部分可以根据情况省略掉。一些例子（`xEn`表示`x`乘以`10n`的意思，而`xE-n`表示`x`除以`10n`的意思）：

```go
1.23
01.23 // == 1.23
.23
1.
// 一个e或者E随后的数值是指数值（底数为10）。
// 指数值必须为一个可以带符号的十进制整数字面量。
1.23e2  // == 123.0
1e-1    // == 0.1
```

十六进制浮点数文字表示

浮点类型的零值的标准字面量形式为`0.0`。 当然其它很多形式也是合法的，比如`0.`、`.0`、`0e0`和`0x0p0`等。

#### 虚部字面量形式

一个虚部值的字面量形式由一个浮点数字面量或者一个整数字面量和其后跟随的一个小写的字母`i`组成

复数零值的标准字面表示为`0.0+0.0i`。 当然`0i`、`.0i`、`0+0i`等表示也是合法的。

#### 数值字面表示中使用下划线分段来增强可读性

从Go 1.13开始，下划线`_`可以出现在整数、浮点数和虚部数字面量中，以用做分段符以增强可读性。

在一个数值字面表示中，一个下划线`_`不能出现在此字面表示的首尾，并且其两侧的字符必须为（相应进制的）数字字符或者进制表示头。



#### rune值的字面量形式

`rune`类型是`int32`类型的别名。 因此，rune类型（泛指）是特殊的整数类型。 一个rune值可以用上面已经介绍的整数类型的字面量形式表示，也可以 一个rune字面量由若干包在一对单引号中的字符组成。

在Go中，一个rune值表示一个Unicode码点。 一般说来，我们可以将一个Unicode码点看作是一个Unicode字符

有些Unicode字符由多个Unicode码点组成。 每个英文或中文Unicode字符值含有一个Unicode码点。

一个rune字面量由若干包在一对单引号中的字符组成。包在单引号中的字符序列表示一个Unicode码点值。

比如：

```go
'a' // 一个英文字符
'π'
'众' // 一个中文字符
下面这些rune字面量形式的变种和'a'是等价的 （字符a的Unicode值是97）
'\141'   // 141是97的八进制表示
'\x61'   // 61是97的十六进制表示
'\u0061'
'\U00000061'
```

`\`之后必须跟随三个八进制数字字符（0-7）表示一个byte值， `\x`之后必须跟随两个十六进制数字字符（0-9，a-f和A-F）表示一个byte值， `\u`之后必须跟随四个十六进制数字字符表示一个rune值（此rune值的高四位都为0）， `\U`之后必须跟随八个十六进制数字字符表示一个rune值。 这些八进制和十六进制的数字字符序列表示的整数必须是一个合法的Unicode码点值，否则编译将失败。

如果一个rune字面量中被单引号包起来的部分含有**两个字符**， 并且第一个字符是`\`，第二个字符不是`x`、 `u`和`U`，那么这两个字符将被转义为一个特殊字符。 目前支持的转义组合为：

```go
\a   (rune值：0x07) 铃声字符
\b   (rune值：0x08) 退格字符（backspace）
\f   (rune值：0x0C) 换页符（form feed）
\n   (rune值：0x0A) 换行符（line feed or newline）
\r   (rune值：0x0D) 回车符（carriage return）
\t   (rune值：0x09) 水平制表符（horizontal tab）
\v   (rune值：0x0b) 竖直制表符（vertical tab）
\\   (rune值：0x5c) 一个反斜杠（backslash）
\'   (rune值：0x27) 一个单引号（single quote）
```

```go
println('\n') // 10
println('\n' == 10)     // true
println('\n' == '\x0A') // true
```

rune类型的零值常用 `'\000'`、`'\x00'`或`'\u0000'`等来表示。

#### 字符串值的字面量形式

在Go中，字符串值是UTF-8编码的， 所有的Go源代码都必须是UTF-8编码的。

两种形式： 一种是解释型字面表示（interpreted string literal，双引号风格）。 另一种是直白字面表示（raw string literal，反引号风格）

```go
// 解释形式， \n将被转义为一个换行符，每个\"将被转义为一个双引号字符。
"Hello\nworld!\n\"你好世界\""

// 直白形式
`Hello
world!
"你好世界"`
```

双引号风格的字符串字面量中支持`\"`转义，但不支持`\'`转义；而rune字面量则刚好相反。

以`\`、`\x`、`\u`和`\U`开头的rune字面量（不包括两个单引号）也可以出现在双引号风格的字符串字面量中。

```go
// “人”的Unicode值为4eba，它的UTF-8
// 编码为三个字节：0xe4 0xba 0xba。
"\xe4\xba\xba"
```

在UTF-8编码中，一个Unicode码点（rune）可能由1到4个字节组成。 每个英文字母的UTF-8编码只需要一个字节；每个中文字符的UTF-8编码需要三个字节。

字符串类型的零值在代码里用 `""`或``表示。

### 基本数值类型字面量的适用范围

当一个数值型的字面量用来表示一个整数基本类型的值时，舍入是不允许的。 比如，`1.0`可以表示任何基本整数类型的值，但`1.01`却不可以。 当一个数值型的字面量用来表示一个非整数基本类型的值时，舍入（或者精度丢失）是允许的。

# 常量和变量

### 类型不确定值（untyped value）和类型确定值（typed value）

有些值的类型有很多可能性。 这些值称为类型不确定值。对于大多数类型不确定值来说，它们各自都有一个默认类型， 除了预声明的`nil`。`nil`是没有默认类型的。 

显式类型转换的形式为`T(v)`，其表示将一个值`v`转换为类型`T`。 编译器将`T(v)`的转换结果视为一个类型为`T`的类型确定值。 当然，对于一个特定的类型`T`，`T(v)`并非对任意的值`v`都合法。

显式转换`T(v)`合法情况：

1、`v`[可以表示为](https://gfw.go101.org/article/basic-types-and-value-literals.html#representability)`T`类型的一个值。 转换结果为一个类型为`T`的类型确定常量值。

2、`v`的默认类型是一个整数类型（`int`或者`rune`） 并且`T`是一个字符串类型。 转换`T(v)`将`v`看作是一个Unicode码点。 转换结果为一个类型为`T`的字符串常量。 此字符串常量只包含一个Unicode码点，并且可以看作是此Unicode码点的UTF-8表示形式。 
	对于不在合法的Unicode码点取值范围内的整数`v`， 转换结果等同于字符串字面量`"\uFFFD"`，`0xFFFD`是Unicode标准中的（非法码点的）替换字符值

```
uint(1.0)
float32(123)
float32(0.49999999)
// 只要目标类型不是整数类型，舍入都是允许的。
string(65)          // "A"
string('A')         // "A"
string('\u68ee')    // "森"

string(-1)          // "\uFFFD"
string(65.0) // 字面量65.0的默认类型是float64（不是一个整数类型）
int(1.23)     // 1.23不能被表示为int类型值。
```

### 类型推断

可以在代码中使用一些类型不确定值， 编译器会自动推断出这些类型不确定值在特定情景下应被视为某些特定类型的值。

1,在Go代码中，如果某处需要一个特定类型的值并且一个类型不确定值可以表示为此特定类型的值， 则此类型不确定值可以使用在此处。Go编译器将此类型不确定值视为此特定类型的类型确定值。 这种情形常常出现在运算符运算、函数调用和赋值语句中。

2,有些场景对某些类型不确定值并没有特定的类型要求。 在这种情况下，Go编译器将这些类型不确定值视为类型为它们各自的默认类型的类型确定值。

一个字面（常）量的默认类型取决于它的它为何种字面量形式：

- ​	一个字符串字面量的默认类型是预声明的`string`类型。
- ​	一个布尔字面量的默认类型是预声明的`bool`类型。
- ​	一个整数型字面量的默认类型是预声明的`int`类型。
- ​	一个rune字面量的默认类型是预声明的`rune`（亦即`int32`）类型。
- ​	一个浮点数字面量的默认类型是预声明的`float64`类型。
- ​	如果一个字面量含有虚部字面量，则此字面量的默认类型是预声明的`complex128`类型。

上述两条类型推断规则可以被视为隐式转换规则。

### （有名）常量声明（constant declaration）

关键字`const`用来声明有名常量

```go
const π = 3.1416
const (
	No         = !Yes
	Yes        = true
	MaxDegrees = 360
	Unit       = "弧度"
)
const DoublePi, HalfPi, Unit2 = π * 2, π * 0.5, "度"
```

Go白皮书把上面每行含有一个等号`=`的语句称为一个常量描述（constant specification）。 每个`const`关键字对应一个常量声明。一个常量声明中可以有若干个常量描述。 

常量声明中的等号`=`表示“绑定”而非“赋值”。 每个常量描述将一个或多个字面量绑定到各自对应的有名常量上。 或者说，每个有名常量其实代表着一个字面常量。

上面例子中声明的所有常量都是类型不确定的。 它们各自的默认类型和它们各自代表的字面量的默认类型是一样的。

#### 类型确定有名常量

```go
const X float32 = 3.14
```

也可以使用显式类型转换来声明类型确定常量

```go
const X = float32(3.14)
```

欲将一个字面常量绑定到一个类型确定有名常量上，此字面常量必须能够表示为此常量的确定类型的值。 否则，编译将报错。

```go
const MaxUint uint = (1 << 64) - 1
```

下面这个类型确定常量声明在64位的操作系统上是合法的，但在32位的操作系统上是非法的。 因为一个`uint`值在32位操作系统上的尺寸是32位， `(1 << 64) - 1`将溢出`uint`。（这里，符号`<<`为左移位运算符。）

声明一个常量来表示当前操作系统的位数，或者检查当前操作系统是32位的还是64位的。

```go
const NativeWordBits = 32 << (^uint(0) >> 63) // 64 or 32
const Is64bitOS = ^uint(0) >> 63 != 0
const Is32bitOS = ^uint(0) >> 32 == 0

const MaxUint = ^uint(0)
const MaxInt = int(^uint(0) >> 1)
```

#### 常量声明中的自动补全

在一个包含多个常量描述的常量声明中，除了第一个常量描述，其它后续的常量描述都可以只有标识符部分。 Go编译器将通过照抄前面最紧挨的一个完整的常量描述来自动补全不完整的常量描述。

```go
const (
	X float32 = 3.14
	Y                // 这里必须只有一个标识符
	Z                // 这里必须只有一个标识符

	A, B = "Go", "language"
	C, _
	// 上一行中的空标识符是必需的（如果
	// 上一行是一个不完整的常量描述）。
)
```

自动补全为

```go
const (
	X float32 = 3.14
	Y float32 = 3.14
	Z float32 = 3.14

	A, B = "Go", "language"
	C, _ = "Go", "language"
)
```

#### 在常量声明中使用`iota`

`iota`是Go中预声明（内置）的一个特殊的有名常量。 `iota`被预声明为`0`，但是它的值在编译阶段并非恒定。当此预声明的`iota`出现在一个常量声明中的时候，它的值在第n个常量描述中的值为`n`（从0开始）。 所以`iota`只对含有多个常量描述的常量声明有意义。



```go
const (
	Failed = iota - 1 // == -1
	Unknown           // == 0
	Succeeded         // == 1
)

const (
	Readable = 1 << iota // == 1
	Writable             // == 2
	Executable           // == 4
)
```



### 变量声明和赋值操作语句

变量可以被看作是在运行时刻存储在内存中并且可以被更改的有名字的值。

所有的变量值都是类型确定值

在一个函数体内声明的变量称为局部变量。 在任何函数体外声明的变量称为包级或者全局变量。

#### 标准变量声明形式

起始于一个`var`关键字。 每个`var`关键字跟随着一个变量名。 每个变量名必须为一个[标识符](https://gfw.go101.org/article/keywords-and-identifiers.html#identifier)。

```go
var lang, website string = "Go", "https://golang.org"
```

另外两种变种形式用得更广泛一些。

一种变种形式省略了变量类型（但仍指定了变量的初始值），这时编译器将根据初始值的字面量形式来推断出变量的类型。

一种变种形式省略了初始值（但仍指定了变量类型），这时编译器将使用变量类型的零值做为变量的初始值。

```go
// 变量lang和dynamic的类型将被推断为内置类型string和bool。
var lang, dynamic = "Go", false
var lang, website string      // 两者都被初始化为空字符串。
```

同时声明的多个变量的类型可以不一样。

和常量声明一样，多个变量可以用一对小括号组团在一起被声明。

```go
var (
	lang, bornYear, compiled     = "Go", 2007, true
	announceAt, releaseAt    int = 2009, 2012
	createdBy, website       string
)
```

一般来说，将多个相关的变量声明在一起将增强代码的可读性。

#### 纯赋值语句

变量声明的例子中，等号`=`表示赋值。 一旦一个变量被声明之后，它的值可以被通过纯赋值语句来修改。 多个变量可以同时在一条赋值语句中被修改。

一个赋值语句等号左边的表达式必须是一个可寻址的值、一个映射元素或者一个空标识符。

//常量的=号叫做绑定

常量是不可改变的（不可寻址的），所以常量不能做为目标值出现在纯赋值语句的左边，而只能出现在右边用做源值。 变量既可以出现在纯赋值语句的左边用做目标值，也可以出现在右边用做源值。

空标识符也可以出现在纯赋值语句的左边，表示不关心对应的目标值。 空标识符不可被用做源值。

```go
var x int
var y, z float32
x = N   // ok: N被隐式转换为类型int
y = x   // error: 类型不匹配
x, y = int(y), float32(x) // ok
```

// var a int  = 1.0  ok

//T(v) ，目标类型不是int，则丢失是允许的

#### 短变量声明形式

```go
package main

func main() {
	// 变量lang和year都为新声明的变量。
	lang, year := "Go language", 2007

	// 这里，只有变量createdBy是新声明的变量。
	// 变量year已经在上面声明过了，所以这里仅仅
	// 改变了它的值，或者说它被重新声明了。
	year, createdBy := 2009, "Google Research"

	// 这是一个纯赋值语句。
	lang, year = "Go", 2012

	print(lang, "由", createdBy, "发明")
	print("并发布于", year, "年。")
	println()
}
```

1. ​	短声明形式不包含`var`关键字，并且不能指定变量的类型。
2. ​	短变量声明中的赋值符号必须为`:=`。
3. ​	在一个短声明语句的左侧，已经声明过的变量和新声明的变量可以共存。 但在一个标准声明语句中，所有左侧出现在的变量必须都为新声明的变量。

 **注意**，相对于纯赋值语句，目前短声明语句有一个限制：出现在一个短声明左侧的项必须都为纯标识符。 以后我们将学习到在纯赋值语句的左边可以出现结构体值的字段，指针的解引用和容器类型值的元素索引项等。 但是这些项不能出现在一个变量短声明语句的左边。

**每个局部声明的变量至少要被有效使用一次，否则编译器将报错。 包级变量无此限制。 如果一个变量总是被当作赋值语句中的目标值，那么我们认为这个变量没有被有效使用过。**

避免编译器报错的方法很简单，要么删除相关的变量声明，要么像下面这样，将未曾有效使用过的变量（这里是`r`和`s`）赋给空标识符。

```go
_, _ = r, s // 将r和s做为源值使用一次。
```

**若干包级变量在声明时刻的依赖关系将影响它们的初始化顺序**

下面这个例子中的声明的变量的初始化顺序为`y = 5`、`c = y`、`b = c+1`、`a = b+1`、`x = a+1`。

```go
var x, y = a+1, 5         // 8 5
var a, b, c = b+1, c+1, y // 7 6 5
```

包级变量在初始化的时候不能相互依赖。比如，下面这个变量声明语句编译不通过。

```go
var x, y = y, x
```

所有变量都是可以寻址的，所有常量都是不可被寻址 

### 非常量数字值相关的显式类型转换规则

在Go中，两个类型不一样的[基本类型](https://gfw.go101.org/article/basic-types-and-value-literals.html)值是不能相互赋值的。 我们必须使用显式类型转换将一个值转换为另一个值的类型之后才能进行赋值。

常量数字值的类型转换不能溢出。此规则不适用于非常量数字值的类型转换。 非常量数字值的类型转换中，溢出是允许的。 另外当将一个浮点数非常量值（比如一个变量）转换为一个整数类型的时候，舍入（或者精度丢失）也是允许的。

- ​	当从一个比特位数多的整数类型的非常量整数值向一个比特位数少的整数类型转换的时候，高位的比特将被舍弃，低位的比特将被保留。    我们称这种处理方式为截断（truncated）或者回绕（wrapped around）。
- ​	当从一个非常量的浮点数向一个整数类型转换的时候，浮点数的小数部分将被舍弃（向零靠拢）。
- ​	当从一个非常量整数或者浮点数向一个浮点数类型转换的时候，精度丢失是可以发生的。
- ​	当从一个非常量复数向另一个复数类型转换的时候，精度丢失也是可以发生的。
- ​	当一个显式转换涉及到非常量浮点数或者复数数字值时，如果源值溢出了目标类型的表示范围，则转换结果取决于具体编译器实现（即行为未定义）。



### 作用域

作用域是指一个标识符的可见范围。 一个包级变量或者常量的作用域为其所处于的整个代码包。 一个局部变量或者常量的作用域开始于此变量或者常量的声明的下一行，结束于最内层包含此变量或者常量的声明语句的代码块的结尾

#### 每个常量标识符将在编译的时候被其绑定的字面量所替代

#### 一个类型不确定常量所表示的值在可以溢出其默认类型

```go
//下例中的三个类型不确定常量均溢出了它们各自的默认类型，但是此程序编译和运行都没问题。 
const n = 1 << 64          // 默认类型为int
const r = 'a' + 0x7FFFFFFF // 默认类型为rune
const x = 2e+308           // 默认类型为float64
```

```go
/ 三个类型确定常量。
const n int = 1 << 64           // error: 溢出int
const r rune = 'a' + 0x7FFFFFFF // error: 溢出rune
const x float64 = 2e+308        // error: 溢出float64
```

 

# 函数声明和调用

如果一个函数声明的所有返回结果均为匿名的，则在此函数体内的返回语句`return`关键字后必须跟随一系列返回值，这些返回值和此函数的各个返回结果声明一一对应。

```go
func SquaresOfSumAndDiff(a int64, b int64) (int64, int64) {
	return (a+b) * (a+b), (a-b) * (a-b)
}
```

Go不支持输入参数默认值。每个返回结果的默认值是它的类型的零值。

```go
func SquaresOfSumAndDiff(a, b int64) (s, d int64) {
	return (a+b) * (a+b), (a-b) * (a-b)
	// 上面这行等价于下面这行：
	// s = (a+b) * (a+b); d = (a-b) * (a-b); return
}
```

如果一个函数声明的只包含一个返回结果，并且此返回结果是匿名的，则此函数声明中的返回结果部分不必用小括号括起来。 如果一个函数声明的返回结果列表为空，则此函数声明中的返回结果部分可以完全被省略掉。

```
func VersionString() string {
	return "go1.0"
}
func CompareLower4bits(m, n uint32) (r bool) {
	// 下面这两行等价于：return m&0xFF > n&0xff
	r = m&0xF > n&0xf
	return
}
func doNothing(string, int) {
}
```

一个程序的`main`入口函数必须不带任何输入参数和返回结果。

**注意**，在Go中，所有函数都必须直接声明在包级代码块中。 或者说，任何一个函数都不能被声明在另一个函数体内。 虽然匿名函数（将在下面的某节中介绍）可以定义在函数体内，但匿名函数定义不属于函数声明。

### 函数调用

一个声明的函数可以通过它的名称和一个实参列表来调用。
如果一个实参值的类型和其对应的形参声明的类型不一致，则此实参必须能够隐式转换到其对应的形参的类型。

一个函数的声明可以出现在它的调用之前，也可以出现在它的调用之后。

一个函数调用可以被延迟执行或者在另一个协程（goroutine，或称绿色线程）中执行

### 函数调用的退出阶段

在Go中，当一个函数调用返回后（比如执行了一个`return`语句或者函数中的最后一条语句执行完毕）， 此调用可能并未立即退出。一个函数调从返回开始到最终退出的阶段称为此函数调用的退出阶段（exiting phase）。 函数调用的退出阶段的意义将在讲解[延迟函数](https://gfw.go101.org/article/control-flows-more.html#defer)的时候体现出来。

### 匿名函数

定义一个匿名函数和声明一个函数类似，但是一个匿名函数的定义中不包含函数名称部分。 注意匿名函数定义不是一个函数声明。

一个匿名函数在定义后可以被立即调用

```go
func main() {
	// 这个匿名函数没有输入参数，但有两个返回结果。
	x, y := func() (int, int) {
		println("This fucntion has no parameters.")
		return 3, 4
	}() // 一对小括号表示立即调用此函数。不需传递实参。

	// 下面这些匿名函数没有返回结果。

	func(a, b int) {
		println("a*a + b*b =", a*a + b*b) // a*a + b*b = 25
	}(x, y) // 立即调用并传递两个实参
  
  func() {
		println("x*x + y*y =", x*x + y*y) // x*x + y*y = 25
	}() // 不需传递实参。
}
```

上例中的最后一个匿名函数处于变量`x`和`y`的作用域内，所以在它的函数体内可以直接使用这两个变量。 这样的函数称为闭包（closure）。

事实上，Go中的所有的自定义函数（包括声明的函数和匿名函数）都可以被视为闭包。 这就是为什么Go中的函数使用起来为什么像动态语言中的函数一样灵活。

### 内置函数

`我们可以不引入任何库包的情况下而调用内置函数。比如： println`和`print`函数

# 代码包和包引入

Go代码包（package）用来组织管理代码
必须先引入一个代码包（除了`builtin`标准库包）才能使用其中导出的资源（比如函数、类型、变量和有名常量等）

```go
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func main() {
	rand.Seed(time.Now().UnixNano()) // 设置随机数种子
	fmt.Printf("下一个伪随机数总是%v。\n", rand.Uint32())
}
```

程序入口`main`函数必须处于一个名为`main`的代码包中。

前面几篇文章中使用的内置函数`print`和`println`提供了和`fmt`标准库包中的对应函数相似的功能。 内置函数可以不用引入任何代码包而直接使用。

注意：`print`和`println`这两个内置函数不推荐使用在生产环境，因为它们不保证一定会出现在以后的Go版本中。

`aTime.UnixNano()`将返回从UTC时间的1970年一月一日到`aTime`所表示的时间之间的纳秒数。 返回结果的类型为`int64`。

### `fmt.Printf`函数调用的输出格式

​	`%v`：将被替换为对应实参字符串表示形式。

​	`%T`：将替换为对应实参的类型的字符串表示形式。

​	`%x`：将替换为对应实参的十六进制表示。实参的类型必须为整数，整数数组（array）或者整数切片（slice）等。  

​	`%s`：将被替换为对应实参的字符串表示形式。实参的类型必须为字符串或者字节切片（byte slice）类型。

模块（modules）
一个模块可以被看做是一些拥有一个共同的根目录的代码包集合，即一个代码包树。 每个模块关联着一个根引入路径和一个[语义化版本号](https://semver.org/)

```
GO111MODULE`环境变量 `auto`(默认值)、`on`、`off
```

### `init`函数

在一个代码包中，甚至一个源文件中，可以声明若干名为`init`的函数。 这些`init`函数必须不带任何输入参数和返回结果。
注意：我们不能声明名为`init`的包级变量、常量或者类型。
在进入`main`入口函数之前，每个`init`函数在此包加载的时候将被（串行）执行并且只执行一遍。

## 程序资源初始化顺序

一个程序中所涉及到的所有的在运行时刻要用到的代码包的加载是串行执行的。 在一个程序启动时，每个包中总是在它所有依赖的包都加载完成之后才开始加载。 程序代码包总是最后一个被加载的代码包。每个被用到的包会被而且仅会被加载一次。

在同一个源文件中声明的`init`函数将按从上到下的顺序被调用执行。 对于声明在同一个包中的两个不同源文件中的两个`init`函数，Go语言白皮书推荐（但不强求）按照它们所处于的源文件的名称的词典序列（对英文来说，即字母顺序）来调用。 所以最好不要让声明在同一个包中的两个不同源文件中的两个`init`函数存在依赖关系。

在同一个包内，包级变量将尽量按照它们在代码中的出现顺序被初始化，但是一个包级变量的初始化肯定晚于它所依赖的其它包级变量。



### 完整的引入声明语句形式

```go
import importname "path/to/package"
```

引入名`importname`是可选的，它的默认值为被引入的包的包名（不是目录名）。

 如果一个源文件引入的两个代码包的包名一样，为了防止使编译器产生困惑，我们至少需要用完整形式为其中一个包指定一个不同的引入名以区分这两个包。

一个完整引入声明语句形式的引入名`importname`可以是一个句点(`.`)。 这样的引入称为句点引入。使用被句点引入的包中的导出资源时，限定标识符的前缀必须省略。

```go
import (
	. "fmt"
	. "time"
)

func main() {
	Println("Current time:", Now())
}
```

一般来说，句点引入不推荐使用，因为它们会导致较低的代码可读性。

一个完整引入声明语句形式的引入名`importname`可以是一个空标识符(`_`)。 这样的引入称为匿名引入。一个包被匿名引入的目的主要是为了加载这个包，从而使得这个包中的资源得以初始化。 被匿名引入的包中的`init`函数将被执行并且仅执行一遍。

每个非匿名引入必须至少被使用一次，否则 程序编译不通过。

# 表达式、语句和简单语句

### 简单语句类型列表

Go中有六种简单语句类型：

1. ​	变量短声明语句。
2. ​	纯赋值语句，包括`x op= y`这种运算形式。
3. ​	有返回结果的函数或方法调用，以及通道的接收数据操作 
4. ​	通道的发送数据操作。 
5. ​	空语句 
6. ​	自增（`x++`）和自减（`x--`）语句。

注意：和C/C++不一样，在Go中，自增和自减语句不能被当作表达式使用。

简单语句这个概念在Go中比较重要，所以请牢记这六种简单语句类型。

# 基本流程控制语法

- ​	`if-else`条件分支代码块；
- ​	`for`循环代码块；
- ​	`switch-case`多条件分支代码块。



- ​	[容器类型](https://gfw.go101.org/article/container.html#iteration)相关的`for-range`循环代码块。
- ​	[接口类型](https://gfw.go101.org/article/interface.html#type-switch)相关的`type-switch`多条件分支代码块。
- ​	[通道类型](https://gfw.go101.org/article/channel.html#select)相关的`select-case`多分支代码块。

Go也支持`break`、`continue`和`goto`等跳转语句。 另外，Go还支持一个特有的`fallthrough`跳转语句。

Go所支持的六种流程控制代码快中，除了`if-else`条件分支代码块，其它五种称为可跳出代码块。 我们可以在一个可跳出代码块中使用`break`语句以跳出此代码块。

`for`和`for-range`两种循环代码块中使用`continue`语句提前结束一个循环步。 除了这两种循环代码块，其它四种代码块称为分支代码块。

### `if-else`条件分支控制代码块

```go
if InitSimpleStatement; Condition {
	// do something
} else {
	// do something
}
```

`InitSimpleStatement`部分是可选的，如果它没被省略掉，则它必须为一条[简单语句](https://gfw.go101.org/article/expressions-and-statements.html#simple-statements)。 如果它被省略掉，它可以被视为一条空语句（简单语句的一种）。 

`Condition`必须为一个结果为布尔值的[表达式](https://gfw.go101.org/article/expressions-and-statements.html#expressions)（它被称为条件表达式）。 `Condition`部分可以用一对小括号括起来

如果`InitSimpleStatement`语句是一个变量短声明语句，则在此语句中声明的变量被声明在外层的隐式代码块中。

### `for`循环代码块

```go
for InitSimpleStatement; Condition; PostSimpleStatement {
	// do something
}
```

​	`InitSimpleStatement`（初始化语句）和`PostSimpleStatement`（步尾语句）两个部分必须均为简单语句，并且`PostSimpleStatement`不能为一个变量短声明语句。

​	`Condition`必须为一个结果为布尔值的表达式（它被称为条件表达式）

所有这三个刚提到的部分都是可选的。

在一个`for`循环流程控制中，如果`InitSimpleStatement`和`PostSimpleStatement`两部分同时被省略（可将它们视为空语句），则和它们相邻的两个分号也可被省略。 这样的形式被称为只有条件表达式的`for`循环。只有条件表达式的`for`循环和很多其它语言中的`while`循环类似。

```go
for ; i < 10; {
	fmt.Println(i)
	i++
}
for i < 20 {
	fmt.Println(i)
	i++
}


// 下面这几个循环是等价的。
for ; true; {
}
for true {
}
for ; ; {
}
for {
}
```

如果条件表达式部分被省略，则编译器视其为`true`

我们可以在内嵌的循环体（显式代码块）中声明同名变量来遮挡在`InitSimpleStatement`中声明的变量。

```go
for i := 0; i < 3; i++ {
	fmt.Print(i)
	i := i // 这里声明的变量i遮挡了上面声明的i。
	       // 右边的i为上面声明的循环变量i。
	i = 10 // 新声明的i被更改了。
	_ = i
}
```

一条`break`语句可以用来提前跳出包含此**`break`语句的最内层`for`循环**。

一条`continue`语句可以被用来提前结束包含此`continue`语句的**最内层`for`循环的当前循环步（步尾语句仍将得到执行）**

### `switch-case`流程控制代码块

```go
switch InitSimpleStatement; CompareOperand0 {
case CompareOperandList1:
	// do something
case CompareOperandList2:
	// do something
...
case CompareOperandListN:
	// do something
default:
	// do something
}
```

`InitSimpleStatement`部分必须为一条简单语句，它是可选的。

`CompareOperand0`部分必须为一个表达式（如果它没被省略的话，见下）。 此表达式的估值结果总是被视为一个类型确定值。如果它是一个类型不确定值，则它被视为类型为它的默认类型的类型确定值。 因为这个原因，此表达式不能为类型不确定的`nil`值。 `CompareOperand0`常被称为switch表达式。

每个`CompareOperandListX`部分（`X`表示`1`到`N`）必须为一个用（英文）逗号分隔开来的表达式列表。 其中每个表达式都必须能和`CompareOperand0`表达式进行比较。 每个这样的表达式常被称为case表达式。 **如果其中case表达式是一个类型不确定值，则它必须能够自动隐式转化为对应的switch表达式的类型，否则编译将失败。**

每个`switch-case`流程控制代码块中最多只能有一个`default`分支（默认分支）。

`break`可以使用在一个`switch-case`流程控制的任何分支代码块之中以提前跳出此`switch-case`流程控制。

```go
import (
	"fmt"
	"math/rand"
	"time"
)

func main() {
	rand.Seed(time.Now().UnixNano())
	switch n := rand.Intn(100); n % 9 {
	case 0:
		fmt.Println(n, "is multiple of 9")
	case 1, 2, 3:
		fmt.Println(n, "mod 9 is 1,2,3")
	case 4, 5, 6:
		fmt.Println(n, "mod 9 is 4,5,6")
	default:
		fmt.Println(n, "mod is 7,8")
	}
}
```

`rand.Intn`函数将返回一个从`0`到所传实参之间类型为`int`的随机数

如何让执行从一个`case`分支代码块的结尾跳入下一个分支代码块？Go提供了一个`fallthrough`关键字来完成这个任务。一条`fallthrough`语句必须为一个分支代码块中的最后一条语句。一条`fallthrough`语句不能出现在一个`switch-case`流程控制中的最后一个分支代码块中。 

```go
case 0, 1, 2, 3, 4:
	fmt.Println("n =", n)
	// 此整个if代码块为当前分支中的最后一条语句
	if true {
		fallthrough // error: 不是当前分支中的最后一条语句
	}
case 5, 6, 7, 8:
```

一个`switch-case`流程控制中的`InitSimpleStatement`语句和`CompareOperand0`表达式都是可选的。 如果`CompareOperand0`表达式被省略，则它被认为类型为`bool`类型的`true`值。 如果`InitSimpleStatement`语句被省略，其后的分号也可一并被省略。

Go中另外一个和其它语言的显著不同点是`default`分支不必一定为最后一个分支。

### `goto`跳转语句和跳转标签声明

在一个`goto`跳转语句中，`goto`关键字后必须跟随一个表明跳转到何处的跳转标签。 我们使用`LabelName:`这样的形式来声明一个名为`LabelName`的跳转标签，其中`LabelName`必须为一个标识符。 一个不为空标识符的跳转标签声明后必须被使用至少一次。

一条跳转标签声明之后必须立即跟随一条语句。 如果此声明的跳转标签使用在一条`goto`语句中，则当此条`goto`语句被执行的时候，执行将跳转到此跳转标签声明后跟随的语句。

一个跳转标签必须声明在一个函数体内，此跳转标签的使用可以在此跳转标签的声明之后或者之前，但是此跳转标签的使用不能出现在此跳转标签声明所处的最内层代码块之外。

```go
func main() {
	i := 0

Next: // 跳转标签声明
	fmt.Println(i)
	i++
	if i < 5 {
		goto Next // 跳转
	}
}
```

```go
func main() {
goto Label1 // error
	{
		Label1:
		goto Label2 // error
	}
	{
		Label2:
	}
}
```

如果一个跳转标签声明在某个变量的作用域内，则此跳转标签的使用不能出现在此变量的声明之前。

```go
func main() {
	i := 0
Next:
	if i >= 5 {
		// error: goto Exit jumps over declaration of k
		goto Exit
	}

	k := i + i
	fmt.Println(k)
	i++
	goto Next
Exit: // 此标签声明在k的作用域内，但
      // 它的使用在k的作用域之外。
}
```

可以改变变量`k`的作用域：

```go
func main() {
	i := 0
Next:
	if i >= 5 {
		goto Exit
	}
	// 创建一个显式代码块以缩小k的作用域。
	{
		k := i + i
		fmt.Println(k)
	}
	i++
	goto Next
Exit:
}
```

### 包含跳转标签的`break`和`continue`语句

```go
package main

import "fmt"

func FindSmallestPrimeLargerThan(n int) int {
Outer:
	for n++; ; n++{
		for i := 2; ; i++ {
			switch {
			case i * i > n:
				break Outer
			case n % i == 0:
				continue Outer
			}
		}
	}
	return n
}

func main() {
	for i := 90; i < 100; i++ {
		n := FindSmallestPrimeLargerThan(i)
		fmt.Print("最小的比", i, "大的素数为", n)
		fmt.Println()
	}
}
```

//continue Outer 到 n++
//break Outer 到 return n

# 协程、延迟函数调用、以及恐慌和恢复

### 协程（goroutine）

现代CPU一般含有多个核，并且一个核可能支持多线程。换句话说，现代CPU可以同时执行多条指令流水线。 为了将CPU的能力发挥到极致，我们常常需要使我们的程序支持并发（concurrent）计算。

并发计算是指若干计算可能在某些时间片段内同时运行的情形。 下面这两张图描绘了两种并发计算的场景。

<img src="/Users/demo/Library/Application Support/typora-user-images/image-20200520180122427.png" alt="image-20200520180122427" style="zoom:50%;" />

在并行计算中，多个计算在任何时间点都在同时运行。并行计算属于特殊的并发计算。

在Go编程中，协程是创建并发计算的唯一途径。

协程有时也被称为绿色线程。绿色线程是由程序的运行时（runtime）维护的线程。一个绿色线程的开销（比如内存消耗和情景转换）比一个系统线程常常小得多。 只要内存充足，一个程序可以轻松支持上万个并发协程。

Go不支持创建系统线程，所以协程是一个Go程序内部唯一的并发实现方式。

每个Go程序启动的时候只有一个对用户可见的协程，我们称之为主协程。 一个协程可以开启更多其它新的协程。在Go中，开启一个新的协程是非常简单的。 我们只需在一个函数调用之前使用一个`go`关键字，即可让此函数调用运行在一个新的协程之中。 当此函数调用退出后，这个新的协程也随之结束了。我们可以称此函数调用为一个协程调用（或者为此协程的启动调用）。 一个协程调用的所有返回值（如果存在的话）必须被全被舍弃。 

```go
import (
	"log"
	"math/rand"
	"time"
)

func SayGreetings(greeting string, times int) {
	for i := 0; i < times; i++ {
		log.Println(greeting)
		d := time.Second * time.Duration(rand.Intn(5)) / 2
		time.Sleep(d) // 睡眠片刻（随机0到2.5秒）
	}
}

func main() {
	rand.Seed(time.Now().UnixNano())
	log.SetFlags(0)
	go SayGreetings("hi!", 10)
	go SayGreetings("hello!", 10)
	time.Sleep(2 * time.Second)
}
```

当一个程序的主协程退出后，此程序也就退出了，即使还有一些其它协程在运行。
上面的例子程序使用了`log`标准库而不是`fmt`标准库中的`Println`函数。 原因是`log`标准库中的打印函数是经过了同步处理的（下一节将解释什么是并发同步），而`fmt`标准库中的打印函数却没有被同步。 如果我们在上例中使用`fmt`标准库中的`Println`函数，则不同协程的打印可能会交织在一起。（虽然对此例来说，交织的概率很低。）

### 并发同步（concurrency synchronization）

不同的并发计算可能共享一些资源，其中共享内存资源最为常见。 在一个并发程序中，常常会发生下面的情形：

- ​	在一个计算向一段内存写数据的时候，另一个计算从此内存段读数据，结果导致读出的数据的完整性得不到保证。
- ​	在一个计算向一段内存写数据的时候，另一个计算也向此段内存写数据，结果导致被写入的数据的完整性得不到保证。

这些情形被称为数据竞争（data race）。并发编程的一大任务就是要调度不同计算，控制它们对资源的访问时段，以使数据竞争的情况不会发生。 此任务常称为并发同步（或者数据同步）。

并发编程中的其它任务包括：

- ​	决定需要开启多少计算；
- ​	决定何时开启、阻塞、解除阻塞和结束哪些计算；
- ​	决定如何在不同的计算中分担工作负载。

上面案例，如何确保主协程在这20条问候语都打印完毕之后才退出呢？

Go支持几种[并发同步技术](https://gfw.go101.org/article/concurrent-synchronization-overview.html)。 其中， [通道](https://gfw.go101.org/article/channel.html)是最独特和最常用的。 但是，为了简单起见，这里我们将使用`sync`标准库包中的`WaitGroup`来同步上面这个程序中的主协程和两个新创建的协程。

`WaitGroup`类型：

- ​	`Add`方法用来注册新的需要完成的任务数。
- ​	`Done`方法用来通知某个任务已经完成了。
- ​	一个`Wait`方法调用将阻塞（等待）到所有任务都已经完成之后才继续执行其后的语句。

```go
var wg sync.WaitGroup

func SayGreetings(greeting string, times int) {
	for i := 0; i < times; i++ {
		log.Println(greeting)
		d := time.Second * time.Duration(rand.Intn(5)) / 2
		time.Sleep(d)
	}
	wg.Done() // 通知当前任务已经完成。
}

func main() {
	rand.Seed(time.Now().UnixNano())
	log.SetFlags(0)
	wg.Add(2) // 注册两个新任务。
	go SayGreetings("hi!", 10)
	go SayGreetings("hello!", 10)
	wg.Wait() // 阻塞在这里，直到所有任务都已完成。
}
```

### 协程的状态

我们可以看到一个活动中的协程可以处于两个状态：**运行状态**和**阻塞状态**。一个协程可以在这两个状态之间切换。 比如上例中的主协程在调用`wg.Wait`方法的时候，将从运行状态切换到阻塞状态；当两个新协程完成各自的任务后，主协程将从阻塞状态切换回运行状态。

注意，一个处于睡眠中的（通过调用`time.Sleep`）或者在等待系统调用返回的协程被认为是处于运行状态，而不是阻塞状态。

当一个新协程被创建的时候，它将自动进入运行状态，一个协程只能从运行状态而不能从阻塞状态退出。 如果因为某种原因而导致某个协程一直处于阻塞状态，则此协程将永远不会退出。 除了极个别的应用场景，在编程时我们应该尽量避免出现这样的情形。

一个处于阻塞状态的协程不会自发结束阻塞状态，它必须被另外一个协程通过某种并发同步方法来被动地结束阻塞状态。 如果一个运行中的程序当前所有的协程都出于阻塞状态，则这些协程将永远阻塞下去，程序将被视为死锁了。 当一个程序死锁后，官方标准编译器的处理是让这个程序崩溃。

比如下面这个程序将在运行两秒钟后崩溃。

```go
func main() {
	wg.Add(1)
	go func() {
		time.Sleep(time.Second * 2)
		wg.Wait() // 阻塞在此
	}()
	wg.Wait() // 阻塞在此
}
```

### 协程的调度

并非所有处于运行状态的协程都在执行。在任一时刻，只能最多有和逻辑CPU数目一样多的协程在同时执行。 我们可以调用[`runtime.NumCPU`](https://golang.google.cn/pkg/runtime/#NumCPU)函数来查询当前程序可利用的逻辑CPU数目。 每个逻辑CPU在同一时刻只能最多执行一个协程。Go运行时（runtime）必须让逻辑CPU频繁地在不同的处于运行状态的协程之间切换，从而每个处于运行状态的协程都有机会得到执行。 这和操作系统执行系统线程的原理是一样的。

标准编译器采纳了一种被称为[M-P-G模型](https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw)的算法来实现协程调度。 其中，**M**表示系统线程，**P**表示逻辑处理器（并非上述的逻辑CPU），**G**表示协程。 大多数的调度工作是通过逻辑处理器（**P**）来完成的。 逻辑处理器像一个监工一样通过将不同的处于运行状态协程（**G**）交给不同的系统线程（**M**）来执行。 一个协程在同一时刻只能在一个系统线程中执行。一个执行中的协程运行片刻后将自发地脱离让出一个系统线程，从而使得其它处于等待子状态的协程得到执行机会。

在运行时刻，我们可以调用[`runtime.GOMAXPROCS`](https://golang.google.cn/pkg/runtime/#GOMAXPROCS)函数来获取和设置逻辑处理器的数量。 对于官方标准编译器，在Go 1.5之前，默认初始逻辑处理器的数量为1；自从Go 1.5之后，默认初始逻辑处理器的数量和逻辑CPU的数量一致。 此新的默认设置在大多数情况下是最佳选择。但是对于某些文件操作十分频繁的程序，设置一个大于`runtime.NumCPU()`的`GOMAXPROCS`值可能是有好处的。

我们也可以通过设置`GOMAXPROCS`环境变量来设置一个Go程序的初始逻辑处理器数量。

### 延迟函数调用（deferred function call）

一个函数调用可以跟在一个`defer`关键字后面，形成一个延迟函数调用。 和协程调用类似，被延迟的函数调用的所有返回值必须全部被舍弃。

当一个函数调用被延迟后，它不会立即被执行。它将被推入由当前协程维护的一个**延迟调用堆栈**。 当一个函数调用（可能是也可能不是一个延迟调用）返回并进入它的**[退出阶段](https://gfw.go101.org/article/function-declarations-and-calls.html#exiting-phase)**后，所有在此函数调用中已经被推入的延迟调用将被按照它们被推入堆栈的顺序逆序执行。 当所有这些延迟调用执行完毕后，此函数调用也就真正退出了。

每个协程维护着两个调用堆栈。

- ​	一个是正常的函数调用堆栈。在此堆栈中，相邻的两个调用存在着调用关系。晚进入堆栈的调用被早进入堆栈的调用所调用。 此堆栈的中最早被推入的调用是对应协程的启动调用。
- ​	另一个堆栈是上面提到的延迟调用堆栈。处于延迟调用堆栈中的任意两个调用之间不存在调用关系。

**一个延迟调用可以修改包含此延迟调用的最内层函数的返回值**

```go
func Triple(n int) (r int) {
	defer func() {
		r += n // 修改返回值
	}()

	return n + n // <=> r = n + n; return
}

func main() {
	fmt.Println(Triple(5)) // 15
}
```



延迟调用对于恐慌/恢复特性是必要的。
延迟函数调用可以帮助我们写出更整洁和更鲁棒的代码

### 协程和延迟调用的实参的估值时刻

- ​	对于一个延迟函数调用，它的实参是在此调用被推入延迟调用堆栈的时候被估值的。
- ​	对于一个协程调用，它的实参是在此协程被创建的时候估值的。

一个匿名函数体内的表达式是在此函数被执行的时候才会被逐个估值的，不管此函数是被普通调用还是延迟/协程调用。

```go
func main() {
	func() {
		for i := 0; i < 3; i++ {
			defer fmt.Println("a:", i)
		}
	}()
	fmt.Println()
	func() {
		for i := 0; i < 3; i++ {
			defer func() {
				fmt.Println("b:", i)
			}()
		}
	}()
}
运行之，将得到如下结果：
为第一个循环中的i是在fmt.Println函数调用被推入延迟调用堆栈的时候估的值，而第二个循环中的i是在第二个匿名函数调用的退出阶段估的值（此时循环变量i的值已经变为3）。 
a: 2
a: 1
a: 0

b: 3
b: 3
b: 3
```

```go
		for i := 0; i < 3; i++ {
			i := i // 在下面的调用中，左i遮挡了右i。
			defer func() {
				// 此i为上面的左i，非循环变量i。
				fmt.Println("b:", i)
			}()
		}
b: 2
b: 1
b: 0
```

### 恐慌（panic）和恢复（recover）

Go不支持异常抛出和捕获，而是推荐使用返回值显式返回错误。 不过，Go支持一套和异常抛出/捕获类似的机制。此机制称为恐慌/恢复（panic/recover）机制。

我们可以调用内置函数`panic`来产生一个恐慌以使当前协程进入恐慌状况。一个恐慌不会蔓延到其它协程。

进入恐慌状况是另一种使当前函数调用开始返回的途径。 一旦一个函数调用产生一个恐慌，此函数调用将立即进入它的退出阶段，在此函数调用中被推入堆栈的延迟调用将按照它们被推入的顺序逆序执行。

通过在一个延迟函数调用之中调用内置函数`recover`，当前协程中的一个恐慌可以被消除，从而使得当前协程重新进入正常状况。

**如果一个协程在恐慌状况下退出，它将使整个程序崩溃。**

内置函数`panic`和`recover`的声明原型如下：

```go
func panic(v interface{})
func recover() interface{}
```

```go
func main() {
	defer func() {
		fmt.Println("正常退出")
	}()
	fmt.Println("嗨！")
	defer func() {
		v := recover()
		fmt.Println("恐慌被恢复了：", v)
	}()
	panic("拜拜！") // 产生一个恐慌
	fmt.Println("执行不到这里")
}
```

Go运行时（runtime）会在若干情形下产生恐慌，比如一个整数被0除的时候。

一般说来，恐慌用来表示正常情况下不应该发生的逻辑错误。 如果这样的一个错误在运行时刻发生了，则它肯定是由于某个bug引起的。 另一方面，非逻辑错误是现实中难以避免的错误，它们不应该导致恐慌。 我们必须正确地对待和处理非逻辑错误。

### 一些致命性错误不属于恐慌

对于官方标准编译器来说，很多致命性错误（比如堆栈溢出和内存不足）不能被恢复。它们一旦产生，程序将崩溃。

# Go类型系统

基本类型

### 组合类型（composite type）

- [指针类型](https://gfw.go101.org/article/pointer.html) - 类C指针

- [结构体类型](https://gfw.go101.org/article/struct.html) - 类C结构体

- [函数类型](https://gfw.go101.org/article/function.html) - 函数类型在Go中是一种一等公民类别

- 容器类型

  ，包括: 

  - 数组类型 - 定长容器类型
  - 切片类型 - 动态长度和容量容器类型
  - 映射类型（map）- 也常称为字典类型。在标准编译器中映射是使用哈希表实现的。

- [通道类型](https://gfw.go101.org/article/channel.html) - 通道用来同步并发的协程

- [接口类型](https://gfw.go101.org/article/interface.html) - 接口在反射和多态中发挥着重要角色

非定义组合类型可以用它们各自的字面表示形式来表示

```go
// 假设T为任意一个类型，Tkey为一个支持比较的类型。

*T         // 一个指针类型
[5]T       // 一个元素类型为T、元素个数为5的数组类型
[]T        // 一个元素类型为T的切片类型
map[Tkey]T // 一个键值类型为Tkey、元素类型为T的映射类型

// 一个结构体类型
struct {
	name string
	age  int
}

// 一个函数类型
func(int) (bool, string)

// 一个接口类型
interface {
	Method0(string) int
	Method1() (int, bool)
}

// 几个通道类型
chan T
chan<- T
<-chan T
```

### 语法：类型定义（type definition declaration）

在Go中，我们可以用如下形式来定义新的类型。在此语法中，`type`为一个关键字。

```go
// 定义单个类型。
type NewTypeName SourceType

// 定义多个类型。
type (
	NewTypeName1 SourceType1
	NewTypeName2 SourceType2
)
```

包级类型（以及下一节将要介绍的类型别名）的名称不能为[`init`](https://gfw.go101.org/article/packages-and-imports.html#init)

注意：

- ​	一个新定义的类型和它的源类型为两个不同的类型。
- ​	在两个不同的类型定义中的定义的两个类型肯定为两个不同的类型。
- ​	一个新定义的类型和它的源类型的底层类型 一致并且它们的值可以相互显式转换。
- ​	类型定义可以出现在函数体内。

```go
type (
	MyInt int
	Age   int
	Text  string
)

type IntPtr *int
type Book struct{author, title string; pages int}
type Convert func(in0 int, in1 bool)(out0 int, out1 string)
type StringArray [5]string
type StringSlice []string

type PersonAge map[string]int
type MessageQueue chan string
type Reader interface{Read([]byte) int}
```

### 语法：类型别名声明（type alias declaration）

从Go 1.9开始，我们可以使用下面的语法来声明自定义类型别名。此语法和类型定义类似，但是请注意其中多了一个等号`=`

```go
type (
	Name = string
	Age  = int
)

type table = map[string]int
type Table = map[Name]Age
```

在上面的类型别名声明的例子中，`Name`是内置类型`string`的一个别名，它们表示同一个类型。
文字表示形式`map[string]int`和`map[Name]Age`也表示同一类型。 所以，`table`和`Table`一样表示同一个类型。
尽管两个别名`table`和`Table`表示同一个类型，但`Table`是导出的

### 概念：定义类型和非定义类型（defined type and undefined type）

一个定义类型是一个在某个类型定义声明中定义的类型。

所有的基本类型都是定义类型。一个非定义类型一定是一个组合类型。

在下面的例子中，别名`C`和类型字面表示`[]string`都表示同一个非定义类型。 类型`A`和别名`B`均表示同一个定义类型。

```go
type A []string
type B = A
type C = []string
```

### 概念：有名类型和无名类型（named type and unnamed type）

- ​	一个类型别名将不会被称为一个类型，尽管我们常说它表示着一个类型。
- ​	术语**有名类型**和**定义类型**将被视为完全相同的概念。（同样地，**无名类型**和**非定义类型**亦为同一概念。） 换句话说，当提到“一个类型别名`T`是一个有名类型”，其实际意义是类型别名`T`表示着一个有名类型。 如果`T`表示着一个无名类型，则我们不应该说`T`是一个有名类型，即使别名`T`它本身拥有一个名字。
- ​	当我们提及一个类型名（称），它可能是一个定义类型的名称，也可能是一个类型别名的名称。

### 概念：底层类型（underlying type）

在Go中，每个类型都有一个底层类型。规则：

- 一个内置类型的底层类型为它自己。

- `unsafe`标准库包中定义的`Pointer`类型的底层类型是它自己。

- 一个非定义类型（必为一个组合类型）的底层类型为它自己。
- 在一个类型声明中，新声明的类型和源类型共享底层类型。

```go
// 这四个类型的底层类型均为内置类型int。
type (
	MyInt int
	Age   MyInt
)

// 下面这三个新声明的类型的底层类型各不相同。
type (
	IntSlice   []int   // 底层类型为[]int
	MyIntSlice []MyInt // 底层类型为[]MyInt
	AgeSlice   []Age   // 底层类型为[]Age
)

// 类型[]Age、Ages和AgeSlice的底层类型均为[]Age。
type Ages AgeSlice
```

如何溯源一个声明的类型的底层类型？规则很简单，在溯源过程中，当遇到一个内置类型或者非定义类型时，溯源结束。

<img src="/Users/demo/Library/Application Support/typora-user-images/image-20200521104121970.png" alt="image-20200521104121970" style="zoom:50%;" />

在Go中，

- 底层类型为内置类型`bool`的类型称为**布尔类型**；
- 底层类型为任一内置整数类型的类型称为**整数类型**；
- 底层类型为内置类型`float32`或者`float64`的类型称为**浮点数类型**；
- 底层类型为内置类型`complex64`或`complex128`的类型称为**复数类型**；
- 整数类型、浮点数类型和复数类型统称为**数字值类型**；
- 底层类型为内置类型`string`的类型称为**字符串类型**。

底层类型这个概念在[类型转换、赋值和比较规则](https://gfw.go101.org/article/value-conversions-assignments-and-comparisons.html)中扮演着重要角色。



### 概念：值（value）

每个类型有一个零值。一个类型的零值可以看作是此类型的默认值。 预声明的标识符`nil`可以看作是切片、映射、函数、通道、指针（包括非类型安全指针）和接口类型的零值的字面量表示。
指针类型、通道类型和接口类型的值没有字面量表示形式。

### 概念：值部（value part）

在运行时刻，很多值是存储在内存的。每个这样的值都有一个直接部分，但是有一些值还可能有一个或多个间接部分。 每个值部分在内存中都占据一段连续空间。通过[指针](https://gfw.go101.org/article/pointer.html)，一个值的间接部分被此值的直接部分所引用。

### 概念：值尺寸（value size）

一个值存储在在内存中是要占据一定的空间的。此空间的大小称为此值的尺寸。值尺寸是用字节数来衡量的。
某个特定类别的所有类型的值的尺寸都是一样的。因为这个原因，我们也常将一个值的尺寸说成是它的类型的尺寸（或值尺寸）。
可以用`unsafe`标准库包中的`Sizeof`函数来取得任何一个值的尺寸。

### 概念：指针类型的基类型（base type）

如果一个指针类型的底层类型表示为`*T`，则此指针类型的基类型为`T`所表示的类型。

### 概念：结构体类型的字段（field）

一个结构体类型由若干成员变量组成。每个这样的成员变量称为此结构体的一个字段

### 概念：函数类型的签名（signature）

一个函数和其类型的签名由此函数的输入参数和返回结果的类型列表组成。 函数名称和函数体不属于函数签名的构成部分。

### 概念：类型的方法（method）和方法集（method set）

在Go中，我们可以给满足某些条件的类型声明[方法](https://gfw.go101.org/article/method.html)。方法也常被称为成员函数。 一个类型的所有方法组成了此类型的方法集。

### 概念：接口类型的动态类型和动态值

接口类型类型的值称为接口值。一个接口值可以包裹装载一个非接口值。包裹在一个接口值中的非接口值称为此接口值的动态值。此动态值的类型称为此接口值的动态类型。 一个什么也没包裹的接口值为一个零值接口值。零值接口值的动态值和动态类型均为不存在。

一个接口类型可以指定若干个（可以是零个）方法，这些方法形成了此接口类型的方法集。

如果一个类型（可以是接口或者非接口类型）的方法集是一个接口类型的方法集的超集，则我们说此类型[实现](https://gfw.go101.org/article/interface.html#implementation)了此接口类型。

### 概念：一个值的具体类型（concrete type）和具体值（concrete value）

对于一个（类型确定的）非接口值，它的具体类型就是它的类型，它的具体值就是它自己。

一个零值接口值没有具体类型和具体值。 对于一个非零值接口值，它的具体类型和具体值就是它的动态类型和动态值。

### 概念：容器类型

数组、切片和映射是Go中的三种正式意义上的内置容器类型。

有时候，字符串和通道类型也可以被非正式地看作是容器类型。

（正式和非正式的）容器类型的每个值都有一个长度属性。

### 概念：映射类型的键值（key）类型

如果一个映射类型的底层类型表示为`map[Tkey]T`，则此映射类型的键值类型为`Tkey`。 `Tkey`必须为一个可比较类型（见下）。

### 概念：容器类型的元素（element）类型

存储在一个容器值中的所以元素的类型必须为同一个类型。此同一类型称为此容器值的（容器）类型的元素类型。

- 如果一个数组类型的底层类型表示为`[N]T`，则此数组类型的元素类型为`T`所表示的类型。
- 如果一个切片类型的底层类型表示为`[]T`，则此切片类型的元素类型为`T`所表示的类型。
- 如果一个映射类型的底层类型表示为`map[Tkey]T`，则此映射类型的元素类型为`T`所表示的类型。
- 如果一个通道类型的底层类型表示为`chan T`、`chan<- T`或者`<-chan T`，则此通道类型的元素类型为`T`所表示的类型。
- 一个字符串类型的元素类型总是内置类型`byte`（亦即`uint8`）。

### 概念：通道类型的方向

一个通道值可以被看作是先入先出（first-in-first-out，FIFO）队列。一个通道值可能是可读可写的、只读的（receive-only）或者只写的（send-only）。

- ​	一个可读可写的通道值也称为一个双向通道。 一个双向通道类型的底层类型可以被表示为`chan T`。
- ​	我们只能向一个只写的通道值发送数据，而不能从其中接收数据。 只写通道类型的底层类型可以被表示为`chan<- T`。
- ​	我们只能从一个只读的通道值接收数据，而不能向其发送数据。 只读通道类型的底层类型可以被表示为`<-chan T`。

### 事实：可比较类型和不可比较类型

目前（Go 1.14），下面这些类型的值不支持（使用`==`和`!=`运算标识符）比较。这些类型称为不可比较类型。

- 切片类型
- 映射类型
- 函数类型
- 任何包含有不可比较类型的字段的结构体类型和任何元素类型为不可比较类型的数组类型。

其它类型称为可比较类型。

映射类型的键值类型必须为可比较类型。

### 事实：Go对范型（generics）的支持

目前（Go 1.14），Go中范型支持只局限在内置类型和内置函数中。自定义范型还处于草案阶段。

# 指针

### 内存地址

一个内存地址表示操作系统管理的整个内存的中一个偏移量（相对于从整个内存的起始，以字节计数）。

通常地，一个内存地址用一个操作系统原生字（native word）来存储。 一个原生字在32位操作系统上占4个字节，在64位操作系统上占8个字节。，32位操作系统上的理论最大支持内存容量为4GB。

>32位系统里内存地址长度是32位的.  所以32位的地址范围就是从 0000 0000 0000 0000 0000 0000 0000  0000 到 1111 1111 1111 1111 1111 1111 1111 1111 啦（Ox00000000 ~  OxFFFFFFFF)， 这里有几个地址呢？ 明显是有 2^32 个啦. 
>
>   那么2^32到底是多少个？ 2^32 = 4 * 1024(G) * 1024(M) * 1024(K) = 4294967296 , 就是**4G** 啊, 而每1个地址对应1个1个字节， 容量就是1byte， 所以2^32个地址就总共能对应应**4GB** 的内存容量

内存地址的字面形式常用整数的十六进制字面量来表示，比如`0x1234CDEF`。

### 值的地址

一个值的地址是指此值的直接部分占据的内存的起始地址。在Go中，每个值都包含一个直接部分，但有些值可能还包含一个或多个间接部分

### 什么是指针？

我们经常称一个指针为一个内存地址
一个指针此中存储的内存地址为另外一个值的地址。和C指针不一样，为了安全起见，Go指针有很多限制，

### 指针类型和值

​	在Go中，一个非定义指针类型的字面形式为`*T`，其中`T`为一个任意类型。类型`T`称为指针类型`*T`的基类型（base type）。 如果一个指针类型的基类型为`T`，则我们可以称此指针类型为一个`T`指针类型,此指针类型的值只能存储类型为`T`的值的地址。

虽然我们可以声明定义指针类型，但是一般不推荐这么做。非定义指针类型的可读性更高。

如果两个非定义指针类型的基类型为同一类型，则这两个非定义指针类型亦为同一类型。

```go
*int  // 一个基类型为int的非定义指针类型。
**int // 一个多级非定义指针类型，它的基类型为*int。

type Ptr *int // Ptr是一个定义的指针类型，它的基类型为int。
type PP *Ptr  // PP是一个定义的多级指针类型，它的基类型为Ptr。
```

指针类型的零值的字面量使用预声明的`nil`来表示。一个nil指针（常称为空指针）中不存储任何地址。

### 关于引用（reference）这个术语

术语“引用”暗示着一个关系。比如，如果一个指针中存储着另外一个值的地址，则我们可以说此指针值引用着另外一个值；同时另外一个值当前至少有一个引用。

### 如何获取一个指针值？

- 我们可以用内置函数`new`来为任何类型的值开辟一块内存并将此内存块的起始地址做为此值的地址返回。 假设`T`是任一类型，则函数调用`new(T)`返回一个类型为`*T`的指针值。 存储在返回指针值所表示的地址处的值（可被看作是一个匿名变量）为`T`的零值。

- 我们也可以使用前置取地址操作符`&`来获取一个可寻址的值的地址。 对于一个类型为`T`的可寻址的值`t`，我们可以用`&t`来取得它的地址。`&t`的类型为`*T`。

一般说来，一个可寻址的值是指被放置在内存中某固定位置处的一个值（但放置在某固定位置处的一个值并非一定是可寻址的.但是所有常量、函数返回值和强制转换结果都是不可寻址的。 当一个变量被声明的时候，Go运行时将为此变量开辟一段内存。此内存的起始地址即为此变量的地址。

### 指针（地址）解引用

以使用前置解引用操作符`*`来访问存储在一个指针所表示的地址处的值（即此指针所引用着的值）。

解引用是取地址的逆过程。

解引用一个nil指针将产生一个[恐慌](https://gfw.go101.org/article/control-flows-more.html#panic-recover)。

```go
func main(){
  p0 := new(int)   // p0指向一个int类型的零值
	fmt.Println(p0)  // （打印出一个十六进制形式的地址）
	fmt.Println(*p0) // 0

	x := *p0              // x是p0所引用的值的一个复制。
	p1, p2 := &x, &x      // p1和p2中都存储着x的地址。
	                      // x、*p1和*p2表示着同一个int值。
	fmt.Println(p1 == p2) // true
	fmt.Println(p0 == p1) // false
}
```

### 我们为什么需要指针？

```go
func double(x int) {
	x += x
}

func main() {
	var a = 3
	double(a)
	fmt.Println(a) // 3
}
```

`a`的值没有被放大为原来的两倍。因为在Go中，所有的赋值（包括函数调用传参）过程都是一个值复制过程。 所以在上面的`double`函数体内修改的是变量`a`的一个副本，而没有修改变量`a`本身。

```go
func double(x *int) {
	*x += *x
	x = nil // 此行仅为讲解目的
}

func main() {
	var a = 3
	double(&a)
	fmt.Println(a) // 6
	p := &a
	double(p)
	fmt.Println(a, p == nil) // 12 false
}
```

 `x = nil`依旧不能反映到函数外，因为此修改发生在此指针的一个副本上

简而言之，指针提供了一种间接的途径来访问和修改一些值。

### 在Go中返回一个局部变量的地址是安全的

和C不一样，Go是支持垃圾回收的，所以一个函数返回其内声明的局部变量的地址是绝对安全的。

```go
func newInt() *int {
	a := 3
	return &a
}
```

### Go指针的一些限制

#### Go指针不支持算术运算

在Go中，指针是不能参与算术运算的。比如，对于一个指针`p`， 运算`p++`和`p-2`都是非法的。

如果`p`为一个指向一个数值类型值的指针，`*p++`将被编译器认为是合法的并且等价于`(*p)++`。 换句话说，取地址操作符`&`和解引用操作符`*`的优先级都高于自增`++`和自减`--`操作符。

```go
func main() {
	a := int64(5)
	p := &a

	// 下面这两行编译不通过。
	/*
	p++
	p = (&a) + 8
	*/

	*p++
	fmt.Println(*p, a)   // 6 6
	fmt.Println(p == &a) // true

	*&a++
	*&*&a++
	**&p++
	*&*p++
	fmt.Println(*p, a) // 10 10
}
```

#### 一个指针类型的值不能被随意转换为另一个指针类型

只有如下某个条件被满足的情况下，一个类型为`T1`的指针值才能被显式转换为另一个指针类型`T2`：

- 类型`T1`和`T2`的底层类型必须一致（忽略结构体字段的标签）。 特别地，如果类型`T1`和`T2`中只要有一个是[非定义类型](https://gfw.go101.org/article/type-system-overview.html#non-defined-type)并且它们的底层类型一致（考虑结构体字段的标签），则此转换可以是隐式的。

- 类型`T1`和`T2`都为非定义类型并且它们的基类型的底层类型一致（忽略结构体字段的标签）。

类型`Ta`的值不能直接被转换为类型`Tb`，即使是显式转换也是不行的。 但是，通过上述三条事实，通过三层显式转换`Tb((*MyInt)((*int64)(pa)))`，一个`pa`的指针值可以被间接地转换为类型`Tb`。

```go
type MyInt int64
type Ta    *int64
type Tb    *MyInt
```

#### 一个指针值不能和其它任一指针类型的值进行比较

Go指针值是支持（使用比较运算符`==`和`!=`）比较的。 但是，两个指针只有在下列任一条件被满足的时候才可以比较：

1. ​	这两个指针的类型相同。

2. ​	其中一个指针可以被隐式转换为另一个指针的类型。换句话说，这两个指针的类型的底层类型必须一致并且其中一个指针类型为非定义的（考虑结构体字段的标签）。

3. ​	其中一个并且只有一个指针用类型不确定的`nil`标识符表示。

   ```go
   func main() {
   	type MyInt int64
   	type Ta    *int64
   	type Tb    *MyInt
   
   	// 4个不同类型的指针：
   	var pa0 Ta
   	var pa1 *int64
   	var pb0 Tb
   	var pb1 *MyInt
   
   	// 下面这6行编译没问题。它们的比较结果都为true。
   	_ = pa0 == pa1
   	_ = pb0 == pb1
   	_ = pa0 == nil
   	_ = pa1 == nil
   	_ = pb0 == nil
   	_ = pb1 == nil
   
   	// 下面这三行编译不通过。
   	/*
   	_ = pa0 == pb0
   	_ = pa1 == pb1
   	_ = pa0 == Tb(nil)
   	*/
   }
   // pa0 -> Ta -> *int64 内置类型
   // pb0 -> Tb -> *MyInt 非定义类型
   //pa0 pb0 底层类型不一致，不可比较
   ```

### 上述Go指针的限制是可以被打破的

[`unsafe`标准库包](https://gfw.go101.org/article/unsafe.html)中提供的非类型安全指针（`unsafe.Pointer`）机制可以被用来打破上述Go指针的安全限制。 `unsafe.Pointer`类型类似于C语言中的`void*`。 但是，通常地，非类型安全指针机制不推荐在Go日常编程中使用。

# 结构体

### 结构体类型和结构体字面量表示形式

每个非定义结构体类型的字面形式均由`struct`关键字开头，后面跟着用一对大括号`{}`，其中包裹着的一系列字段（field）声明。 一般来说，每个字段声明由一个字段名和字段类型组成。一个结构体类型的字段数目可以为0。

```go
struct {
	title  string
	author string
	pages  int
}
```

有时字段也称为成员变量。
相邻的同类型字段可以声明在一起

```go
struct {
	title, author string
	pages         int
}
```

一个结构体类型的尺寸为它的所有字段的（类型）尺寸之和加上一些填充字节的数目。 常常地，编译器（和运行时）会在一个结构体值的两个相邻字段之间填充一些字节来保证一些字段的地址总是某个整数的倍数。 我们可以在后面的[内存布局](https://gfw.go101.org/article/memory-layout.html)一文中了解到字节填充（padding）和内存地址对齐（memory address alignment）

一个零字段结构体的尺寸为零。

每个结构体字段在它的声明中可以被指定一个标签（tag）。从语法上讲，字段标签可以是任意字符串，它们是可选的，默认为空字符串。 但在实践中，它们应该被表示成用空格分隔的键值对形式，并且每个标签尽量使用直白字面形式（``...``）表示，而键值对中值使用解释型字面形式（`"..."`）表示。 比如下例：

```go
struct {
	Title  string `json:"title" myfmt:"s1"`
	Author string `json:"author,omitempty" myfmt:"s2"`
	Pages  int    `json:"pages,omitempty" myfmt:"n1"`
	X, Y   bool   `myfmt:"b1"`
}
```

注意：上例中的`X`和`Y`字段的标签是一样的。

我们可以使用[反射](https://gfw.go101.org/article/reflection.html#struct-field-tag)来检视字段的标签信息。

每个字段标签的目的取决于具体应用。上面这个例子中的字段标签用来帮助`encoding/json`标准库包来将上面这个结构体类型的某个值编码成JSON数据或者从一份JSON数据解码到上面这个结构体类型的某个值中。在编码和解码过程中，`encoding/json`标准库包中的函数将只考虑导出的结构体字段。

把字段标签当成字段注释来使用不是一个好主意。把字段标签当成字段注释来使用不是一个好主意。

只有导出字段可以被使用在其它代码包中。非导出字段类以于很多其它语言中的私有或者保护型的成员变量。

一个结构体类型中的**字段标签和字段的声明顺序**对此结构体类型的身份识别很重要。 如果两个非定义结构体类型的各个对应字段声明都相同（按照它们的出现顺序），则此两个非定义结构体类型是等同的。 两个字段声明只有在它们的名称、类型和标签都等同的情况下才相同。 注意：**两个声明在不同的代码包中的非导出字段将总被认为是不同的字段。**

一个结构体类型不能（直接或者间接）含有一个类型为此结构类型的字段。

### 结构体字面量表示形式和结构体值的使用

在Go中，语法形式`T{...}`称为一个组合字面量形式（composite literal），其中`T`必须为一个类型名或者类型字面形式。 组合字面量形式可以用来表示结构体类型和内置容器类型 的值。

注意：组合字面量`T{...}`是一个类型确定值，它的类型为`T`。

假设`S`是一个结构体类型并且它的底层类型为`struct{ x int; y bool}`，`S`的零值可以表示成：

1. S{0, false} 在此变种形式中，所有的字段名称均不出现，但每个字段的值必须指定，并且每个字段的出现顺序和它们的声明顺序必须一致。

2. ```
   S{x: 0, y: false}`、`S{y: false, x: 0}`、`S{x: 0}`、`S{y: false}`和`S{}
   ```

字段的出现顺序并不重要。 没有出现的字段的值被编译器认为是它们各自类型的零值。`S{}`是最常用的类型`S`的零值的表示形式。

对于类型`S`的一个值`v`，我们可以用`v.x`和`v.y`来表示它的字段。 `v.x`（或`v.y`）这种形式称为一个选择器（selector）。其中的`v`称为此选择器的属主。 今后，我们称一个选择器中的句点`.`为属性选择操作符。

如果一个组合字面量中最后一项和结尾的`}`处于同一行，则此项后的逗号`,`是可选的；否则此逗号不可省略。

```go
type Book struct {
	title, author string
	pages         int
}

func main() {
	book := Book{"Go语言101", "老貘", 256}
  var _ = Book {
	author: "老貘",
	pages: 256,
	title: "Go语言101", // 这里行尾的逗号不可省略
}

	fmt.Println(book) // {Go语言101 老貘 256}

	// 使用带字段名的组合字面量来表示结构体值。
	book = Book{author: "老貘", pages: 256, title: "Go语言101"}
	// title和author字段的值都为空字符串""，pages字段的值为0。
	book = Book{}
	// title字段空字符串""，pages字段为0。
	book = Book{author: "老貘"}

	// 使用选择器来访问和修改字段值。
	var book2 Book // <=> book2 := Book{}
	book2.author = "Tapir"
	book2.pages = 300
	fmt.Println(book.pages) // 300
}
```

### 关于结构体值的赋值

```go
func f() {
	book1 := Book{pages: 300}
	book2 := Book{"Go语言101", "老貘", 256}

	book2 = book1
	// 上面这行和下面这三行是等价的。
	book2.title = book1.title
	book2.author = book1.author
	book2.pages = book1.pages
}
```

两个结构体值只有在它们的类型的底层类型一样（要考虑字段标签）并且其中至少有一个结构体值的类型为[非定义类型](https://gfw.go101.org/article/type-system-overview.html#non-defined-type)时才可以互相赋值。

### 结构体字段的可寻址性

如果一个结构体值是可寻址的，则它的字段也是可寻址的；反之，一个不可寻址的结构体的字段也是不可寻址的。 不可寻址的字段的值是不可更改的。所有的组合字面量都是不可寻址的。

```go
func main() {
	type Book struct {
		Pages int
	}
	var book = Book{} // 变量值book是可寻址的
	p := &book.Pages
	*p = 123
	fmt.Println(book) // {123}

	// 下面这两行编译不通过，因为Book{}是不可寻址的，
	// 继而Book{}.Pages也是不可寻址的。
	/*
	Book{}.Pages = 123
	p = &Book{}.Pages // <=> p = &(Book{}.Pages)
	*/
}
```

注意：选择器中的属性选择操作符`.`的优先级比取地址操作符`&`的优先级要高。

### 组合字面量不可寻址但可被取地址

一般来说，只有可被寻址的值才能被取地址，但是Go中有一个语法糖（语法例外）：虽然所有的组合字面量都是不可寻址的，但是它们都可被取地址。

```go
func main() {
	type Book struct {
		Pages int
	}
	// Book{100}是不可寻址的，但是它可以被取地址。
	p := &Book{100} // <=> tmp := Book{100}; p := &tmp
	p.Pages = 200
}
```

### 在选择器中，结构体值的指针可以当作结构值来使用

自动解引用

```go
func main() {
	type Book struct {
		pages int
	}
	book1 := &Book{100} // book1是一个指针
	book2 := new(Book)  // book2是另外一个指针
	// 像使用结构值一样来使用结构体值的指针。
	book2.pages = book1.pages
	// 上一行等价于下一行。换句话说，上一行
	// 两个选择器中的指针属主将被自动解引用。
	(*book2).pages = (*book1).pages
}
```

### 关于结构体值的比较

两个结构体值只有在它们的相应字段都相等的情况下才相等。 在比较中，字段名为空标识符`_`的字段将被忽略掉

### 关于结构体值的类型转换

两个类型分别为`S1`和`S2`的结构体值只有在`S1`和`S2`的底层类型相同（忽略掉字段标签）的情况下才能相互转换为对方的类型。 特别地，如果`S1`和`S2`的底层类型相同（要考虑字段标签）并且只要它们其中有一个为非定义类型，则此转换可以是隐式的。

事实上，两个结构体值只有在它们可以相互隐式转换为对方的类型的时候才能相互赋值和比较。

### 匿名结构体类型可以使用在结构体字段声明中

匿名结构体类型允许出现在结构体字段声明中。匿名结构体类型也允许出现在组合字面量中。

通常来说，为了代码可读性，最好少使用匿名结构体类型。

```go
var aBook = struct {
	author struct { // 此字段的类型为一个匿名结构体类型
		firstName, lastName string
		gender              bool
	}
	title string
	pages int
}{
	author: struct {
		firstName, lastName string
		gender              bool
	}{
		firstName: "Mark",
		lastName: "Twain",
	}, // 此组合字面量中的类型为一个匿名结构体类型
	title: "The Million Pound Note",
	pages: 96,
}
```

# 值部

### Go类型分为两大类别（category）

一些Go类型的值可能占据多个内存块。

我们称一个Go值分布在不同内存块上的部分为此值的各个值部（value part）。 一个分布在多个内存块上的值含有一个直接值部和若干被此直接值部[引用着](https://gfw.go101.org/article/pointer.html#references)的间接值部。![image-20200521182719243](/Users/demo/Library/Application Support/typora-user-images/image-20200521182719243.png)

一个指针值存储着另一个值的地址，除非此指针值是一个nil空指针。 我们可以说此指针[引用着](https://gfw.go101.org/article/pointer.html#references)另外一个值，或者说另外一个值正被此指针所引用。

一个值可能被间接引用，比如

- ​	如果一个结构体值`a`含有一个指针字段`b`并且这个指针地段引用着另外一个值`c`，那么我们可以说结构体值`a`也引用着值`c`。
- ​	如果一个值`x`（直接或者间接地）引用着另一个值`y`，并且值`y`（直接或者间接地）引用着第三个值`z`，则我们可以说值`x`间接地引用着值`z`。

我们将一个含有（直接或者间接）指针字段的结构体类型称为一个**指针包裹类型**，将一个含有（直接或者间接）指针的类型称为**指针持有者类型**。 指针类型和指针包裹类型都属于指针持有者类型

### 类型的（可能的）内部实现结构定义

```go
// 映射类型
type _map *hashtableImpl // 目前，官方标准编译器是使用
                         // 哈希表来实现映射的。

// 通道类型
type _channel *channelImpl

// 函数类型
type _function *functionImpl

type _slice struct {
	elements unsafe.Pointer // 引用着底层的元素
	len      int            // 当前的元素个数
	cap      int            // 切片的容量
}
type _string struct {
	elements *byte // 引用着底层的byte元素
	len      int   // 字符串的长度
}
type _interface struct {
	dynamicTypeInfo *struct {
		dynamicType *_type       // 引用着接口值的动态类型
		methods     []*_function // 引用着动态类型的对应方法列表
	}
	dynamicValue unsafe.Pointer // 引用着动态值
}

```

# 数组、切片和映射

容器是用来存储相同类型的元素序列或集合

存储在一个容器中的每个元素值都关联着着一个键值（key）。每个元素可以通过它的键值而被访问到。 一个映射类型的键值类型必须为一个[可比较类型](https://gfw.go101.org/article/type-system-overview.html#types-not-support-comparison)。 数组和切片类型的键值类型均为内置类型`int`。 一个数组或切片的一个元素对应的键值总是一个非负整数下标，此非负整数表示该元素在该数组或切片所有元素中的顺序位置。此非负整数下标亦常称为一个元素索引（index）

每个容器值有一个长度属性，用来表明此容器中当前存储了多少个元素。

一个数组或切片中的每个元素所关联的非负整数索引键值的合法取值范围为左闭右开区间`[0, 此数组或切片的长度)`

 对于这三种容器，元素访问的时间复杂度均为`*O*(1)`。 但是一般来说，映射元素访问消耗的时长要数倍于数组和切片元素访问消耗的时长。 但是映射相对于数组和切片有两个优点：

- ​	映射的键值类型可以是任何可比较类型。
- ​	相对于使用含有大量稀疏索引的数组和切片，使用映射可以节省大量的内存。

### 非定义容器类型的字面表示形式

- 数组类型：`[N]T`
- 切片类型：`[]T`
- 映射类型：`map[K]T`

`T`可为任意类型。`N`必须为一个非负整数常量。
一个数组类型的长度是此数组类型的一部分。比如`[5]int`和`[8]int`是两个不同的类型。
`K`必须为一个[可比较类型](https://gfw.go101.org/article/type-system-overview.html#types-not-support-comparison)。它指定了一个映射类型的键值类型。

```go
const Size = 32

type Person struct {
	name string
	age  int
}

// 数组类型
[5]string
[Size]int
[16][]byte  // 元素类型为一个切片类型：[]byte
[100]Person // 元素类型为一个结构体类型：Person

// 切片类型
[]bool
[]int64
[]map[int]bool // 元素类型为一个映射类型：map[int]bool
[]*int         // 元素类型为一个指针类型：*int

// 映射类型
map[string]int
map[int]bool
map[int16][6]string     // 元素类型为一个数组类型：[6]string
map[bool][]string       // 元素类型为一个切片类型：[]string
map[struct{x int}]*int8 // 元素类型为一个指针类型：*int8；
                        // 键值类型为一个结构体类型。
```

所有切片类型的[尺寸](https://gfw.go101.org/article/type-system-overview.html#value-size)都是一致的，所有映射类型的尺寸也都是一致的。 一个数组类型的尺寸等于它的元素类型的尺寸和它的长度的乘积。长度为零的数组的尺寸为零；元素类型尺寸为零的任意长度的数组类型的尺寸也为零。

### 容器字面量的表示形式

和结构体值类似，容器值的文字表示也可以用组合字面量形式（composite literal）来表示。 比如对于一个容器类型`T`，它的值可以用形式`T{...}`来表示（除了切片和映射的零值外）

```go
// 一个含有4个布尔元素的数组值。
[4]bool{false, true, true, false}

// 一个含有三个字符串值的切片值。
[]string{"break", "continue", "fallthrough"}

// 一个映射值。
map[string]int{"C": 1972, "Python": 1991, "Go": 2009}
```

映射组合字面量中大括号中的每一项称为一个键值对（key-value pair），或者称为一个条目（entry）。

```go
// 下面这些数组字面量都是等价的。
[...]bool{false, true, true, false}
[...]bool{3: false, 1: true, true}
```

`...`表示让编译器推断出相应数组值的类型的长度。

索引下标（即数组和切片的键值）是可选的。 在一个数组或者切片组合字面量中：

- ​	如果一个索引下标出现，它的类型不必是数组和切片类型的键值类型`int`，但它必须是一个可以表示为int值的非负常量； 如果它是一个类型确定值，则它的类型必须为一个基本整数类型。
- ​	**在一个数组或切片组合字面量中，如果一个元素的索引下标缺失，则编译器认为它的索引下标为出现在它之前的元素的索引下标加一。**
- ​	如果出现的第一个元素的索引下标缺失，则它的索引下标被认为是0。

映射组合字面量中元素对应的键值不可缺失，并且它们可以为非常量。

```go
var a uint = 1
var _ = map[uint]int {a : 123} // 没问题
var _ = []int{a: 100}          // error: 下标必须为常量
var _ = [5]int{a: 100}         // error: 下标必须为常量
```

### 容器类型零值的字面量表示形式

和结构体类似，一个数组类型`A`的零值可以表示为`A{}`。 比如，数组类型`[100]int`的零值可以表示为`[100]int{}`。 一个数组零值中的所有元素均为对应数组元素类型的零值。

和指针一样，所有切片和映射类型的零值均用预声明的标识符`nil`来表示。函数、通道和接口类型的零值也用预声明的标识符`nil`来表示。

在运行时刻，即使一个数组变量在声明的时候未指定初始值，它的元素所占的内存空间也已经被开辟出来。 但是一个nil切片或者映射值的元素的内存空间尚未被开辟出来。	

```go
func main() {
	var a []int
	b := []int{}
	fmt.Println(a) // []
	fmt.Println(b) // []
	fmt.Println(a == nil) // true 
	fmt.Println(b == nil) //false
}	
```

`[]T{}`表示类型`[]T`的一个空切片值，它和`nil`是不等价的，` map[K]T{}`同理。

### 容器字面量是不可寻址的但可以被取地址

[结构体（组合）字面量是不可寻址的但却是可以被取地址的](https://gfw.go101.org/article/struct.html#take-composite-literal-address)。 容器字面量也不例外

```go
	pm := &map[string]int{"C": 1972, "Go": 2009}
	ps := &[]string{"break", "continue"}
	pa := &[...]bool{false, true, true, false}
	fmt.Printf("%T\n", pm) // *map[string]int
	fmt.Printf("%T\n", ps) // *[]string
	fmt.Printf("%T\n", pa) // *[4]bool
```

### 内嵌组合字面量可以被简化

在某些情形下，内嵌在其它组合字面量中的组合字面量可以简化为`{...}`（即类型部分被省略掉了）。 内嵌组合字面量前的取地址操作符`&`有时也可以被省略。

```go
var heads = []*[4]byte{
	&[4]byte{'P', 'N', 'G', ' '},
	&[4]byte{'G', 'I', 'F', ' '},
	&[4]byte{'J', 'P', 'E', 'G'},
}
var heads = []*[4]byte{
	{'P', 'N', 'G', ' '},
	{'G', 'I', 'F', ' '},
	{'J', 'P', 'E', 'G'},
}
type language struct {
	name string
	year int
}

var _ = [...]language{
	language{"C", 1972},
	language{"Python", 1991},
	language{"Go", 2009},
}
var _ = [...]language{
	{"C", 1972},
	{"Python", 1991},
	{"Go", 2009},
}
```

```go
type LangCategory struct {
	dynamic bool
	strong  bool
}
var _ = map[LangCategory]map[string]int{
	LangCategory{true, true}: map[string]int{
		"Python": 1991,
		"Erlang": 1986,
	}]
  
var _ = map[LangCategory]map[string]int{
	{true, true}: {
		"Python": 1991,
		"Erlang": 1986,
	},
}
```

最后一个元素后的逗号不能被省略。原因详见后面的[断行规则](https://gfw.go101.org/article/line-break-rules.html)一文。

### 容器值的比较

映射和切片类型都属于不可比较类型。 所以任意两个映射值（或切片值）是不能相互比较的。

尽管两个映射值和切片值是不能比较的，但是一个映射值或者切片值可以和预声明的`nil`标识符进行比较以检查此映射值或者切片值是否为一个零值。

大多数数组类型都是可比较类型，除了元素类型为不可比较类型的数组类型。当比较两个数组值时，它么的对应元素将逐一被比较。这两个数组只有在它们的对应元素都相等的情况下才相等

```go
func main() {
	var a [16]byte
	var s []int
	var m map[string]int

	fmt.Println(a == a)   // true
	fmt.Println(m == nil) // true
	fmt.Println(s == nil) // true
	fmt.Println(nil == map[string]int{}) // false
	fmt.Println(nil == []int{})          // false
}
```

### 查看容器值的长度和容量

容器长度属性（此容器中含有有多少个元素），每个容器值还有一个容量属性。 一个数组值的容量总是和它的长度相等；一个非零映射值的容量可以被认为是无限大的。一个切片值的容量总是不小于此切片值的长度。在编程中，只有切片值的容量有实际意义。

我们可以调用内置函数`len`来获取一个容器值的长度，或者调用内置函数`cap`来获取一个容器值的容量。 这两个函数都返回一个`int`类型确定结果值。 因为非零映射值的容量是无限大，所以`cap`并不适用于映射值。

一个数组值的长度和容量永不改变。同一个数组类型的所有值的长度和容量都总是和此数组类型的长度相等。

切片值的长度和容量可在运行时刻改变。因为此原因，切片可以被认为是动态数组。 

```go
var s []int
s := []int{2, 3, 5}
var m map[int]bool
m := map[int]bool{1: true, 0: false}
```

### 读取和修改容器的元素

一个容器值`v`中存储的对应着键值`k`的元素用语法形式`v[k]`来表示。 今后我们称`v[k]`为一个元素索引表达式。

当一个切片被用做一个`append`函数调用中的基础切片，

- ​	如果添加的元素数量大于此（基础）切片的冗余元素槽位的数量，则一个新的底层内存片段将被开辟出来并用来存放结果切片的元素。 这时，基础切片和结果切片不共享任何底层元素。
- ​	否则，不会有底层内存片段被开辟出来。这时，基础切片中的所有元素也同时属于结果切片。两个切片的元素都存放于同一个内存片段上。

### 容器赋值

当一个映射赋值语句执行完毕之后，目标映射值和源映射值将共享底层的元素。 向其中一个映射中添加（或从一个映射中删除）元素将体现在另一个映射中。

和映射一样，当一个切片赋值给另一个切片后，它们将共享底层的元素。 它们的长度和容量也相等。但是如果以后其中一个切片改变了长度或者容量，此变化不会影响到另一个切片。

当一个数组被赋值给另一个数组，所有的元素都将被从源数组复制到目标数组。赋值完成之后，这两个数组不共享任何元素。

### 添加和删除容器元素

对于一个非零映射值`m`，如果当前`m`中尚未存储条目`(k, e)`，则下面的语法形式将把此条目存入`m`；否则，下面的语法形式将把键值`k`对应的元素值更新为`e`。

```go
m[k] = e
```

内置函数`delete`用来从一个映射中删除一个条目。比如，下面的`delete`调用将把键值`k`对应的条目从映射`m`中删除。 如果映射`m`中未存储键值为`k`的条目，则此调用为一个空操作，它不会产生一个恐慌，即使`m`是一个nil零值映射。

```go
delete(m, k)
```

内置`append`函数是一个[变长参数函数](https://gfw.go101.org/article/function.html#variadic-function)

内置`append`函数，以一个切片为基础，来添加**不定数量**的元素并**返回一个新的切片**。 此新的结果切片包含着基础切片中所有的元素和所有被添加的元素。 注意，**基础切片并未被此`append`函数调用所修改**。
如果切片容量足够append则不会开辟新的内存空间，否则开辟一段新的内存

```go
s0 := []int{2, 3, 5}
s1 := append(s0, 7)      
s2 := append(s1, 11, 13) // 添加两个元素
s3 := append(s0)         // <=> s3 := s0
s4 := append(s0, s0...)  // 以s0为基础添加s0中所有的元素
```

当一个`append`函数调用需要为结果切片开辟内存时，结果切片的容量取决于具体编译器实现。 在这种情况下，对于官方标准编译器，如果基础切片的容量较小，则结果切片的容量至少为基础切片的两倍。 这样做的目的是使结果切片有足够多的冗余元素槽位，以防止此结果切片被用做后续其它`append`函数调用的基础切片时再次开辟内存。

截至目前（Go 1.14），`append`函数调用的第一个实参不能为类型不确定的`nil`。

### 使用内置`make`函数来创建切片和映射

除了使用组合字面量来创建映射和切片，我们还可以使用内置`make`函数来创建映射和切片。 数组不能使用内置`make`函数来创建。内置`make`函数也可以用来创建以后将要介绍的[通道](https://gfw.go101.org/article/channel.html)值。

假设`M`是一个映射类型并且`n`是一个非负整数，

```go
make(M, n) //创建了一个可以容纳至少n个条目而无需再次开辟内存的空映射值
make(M) //创建了一个可以容纳一个小数目的条目而无需再次开辟内存的空映射值，此小数目的值取决于具体编译器实现。 
```

假设`S`是一个切片类型，`length`和`capacity`是两个非负整数，并且`length`小于等于`capacity`

```go
make(S, length, capacity) // 创建了一个长度为length并且容量为capacity的切片
make(S, length) // <=> make(S, length, length) 创建了一个长度为length并且容量也为length的切片。 
```

使用`make`函数创建的切片中的所有元素值均被初始化为（结果切片的元素类型的）零值。

```go
fmt.Println(make(map[string]int)) // map[]
s := make([]int, 3, 5)
fmt.Println(s, len(s), cap(s)) // [0 0 0] 3 5
```

### 使用内置`new`函数来创建容器值

内置`new`函数可以用来为一个任何类型的值开辟内存并返回一个存储有此值的地址的指针。 用`new`函数开辟出来的值均为零值。使用`new`函数来用来创建数组值并非是完全没有意义的，但是在实践中很少这么做，因为使用组合字面量来创建数组值更为方便。

```go
func main() {
	m := *new(map[string]int)   // <=> var m map[string]int
	fmt.Println(m == nil)       // true
	s := *new([]int)            // <=> var s []int
	fmt.Println(s == nil)       // true
	a := *new([5]bool)          // <=> var a [5]bool
	fmt.Println(a == [5]bool{}) // true
}
```

### 容器元素的可寻址性

- ​	可寻址的数组的元素也是可寻址的。不可寻址的数组的元素也是不可寻址的。 原因很简单，因为一个数组中的所有元素均处于此数组的直接部分。
- ​	一个切片值的任何元素都是可寻址的，即使此切片本身是不可寻址的。 这是因为一个切片的底层元素总是存储在一个被开辟出来的内存片段上。
- ​	任何映射元素都是不可寻址的。原因详见[此条问答](https://gfw.go101.org/article/unofficial-faq.html#maps-are-unaddressable)。













































